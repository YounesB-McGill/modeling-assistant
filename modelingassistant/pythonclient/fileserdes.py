"""
Helper module for easy serialization and deserialization of models and metamodels from files.
"""

import importlib
import inspect
from collections.abc import Iterable
from typing import Union
from pyecore.ecore import EObject
from pyecore.resources.resource import Resource, ResourceSet, URI

from classdiagram import classdiagram
from classdiagram.classdiagram import ClassDiagram
from learningcorpus import learningcorpus
from learningcorpus.learningcorpus import LearningCorpus, LearningItem
from stringserdes import SRSET
from constants import CLASS_DIAGRAM_MM, LEARNING_CORPUS_MM, MODELING_ASSISTANT_MM
from modelingassistant import modelingassistant
from modelingassistant.modelingassistant import ModelingAssistant


static_classes_by_name: dict[str, EObject] = {}

for _module in [classdiagram, learningcorpus, modelingassistant]:
    for name, cls in inspect.getmembers(importlib.import_module(_module.name), inspect.isclass):
        if "NamedElement" not in name:
            static_classes_by_name[name] = cls


def load_metamodels(*ecore_files: str) -> ResourceSet:
    """
    Return a ResourceSet loaded with the given metamodels from the ecore file paths.
    """
    rset = SRSET
    for ecore_file in ecore_files:
        mm_root = rset.get_resource(URI(ecore_file)).contents[0]
        rset.metamodel_registry[mm_root.nsURI] = mm_root  # ecore loaded in rset as a metamodel here
    return rset


def set_static_class_for(dynamic_obj: EObject):
    """
    Set the appropriate static class for the given EObject to a dynamic class if it
    can be found in the metamodels' autogenerated code and is unambiguous (ie, not NamedElement).
    """
    dynamic_obj.__class__ = static_classes_by_name[type(dynamic_obj).__name__]


def load_cdm(cdm_file: str) -> ClassDiagram:
    """
    Open a class diagram instance from the given file.
    """
    if not cdm_file.endswith(".cdm"):
        print(f"Warning: attempting to open {cdm_file} with unexpected extension as a *.cdm file.")
    rset = load_metamodels(CLASS_DIAGRAM_MM)
    resource = rset.get_resource(URI(cdm_file))
    class_diagram = resource.contents[0]
    class_diagram.__class__ = ClassDiagram
    for e in class_diagram.eAllContents():
        set_static_class_for(e)
    return class_diagram


def load_ma(ma_file: str) -> ModelingAssistant:
    """
    Open a modeling assistant instance from the given file.
    """
    if not ma_file.endswith(".modelingassistant"):
        print(f"Warning: attempting to open {ma_file} with unexpected extension as a *.modelingassistant file.")
    rset = load_metamodels(CLASS_DIAGRAM_MM, LEARNING_CORPUS_MM, MODELING_ASSISTANT_MM)
    resource = rset.get_resource(URI(ma_file))
    modeling_assistant = resource.contents[0]
    modeling_assistant.__class__ = ModelingAssistant
    for e in modeling_assistant.eAllContents():
        set_static_class_for(e)
    return modeling_assistant


def load_lc(lc_file: str) -> LearningCorpus:
    """
    Open a learning corpus instance from the given file.
    """
    if not lc_file.endswith(".learningcorpus"):
        print(f"Warning: attempting to open {lc_file} with unexpected extension as a *.learningcorpus file.")
    rset = load_metamodels(LEARNING_CORPUS_MM)
    resource = rset.get_resource(URI(lc_file))
    learning_corpus = resource.contents[0]
    # use static autogenerated classes instead of the dynamic pyecore ones inferred from the metamodel
    learning_corpus.__class__ = LearningCorpus
    learning_corpus.learningItems.feature._eType = LearningItem  # pylint: disable=protected-access
    for e in learning_corpus.eAllContents():
        set_static_class_for(e)
    return learning_corpus


def save_to_files(items_by_filename: dict[str, Union[EObject, list[EObject]]]):
    """
    Save the given EObject items to their respective files.
    """
    uri_to_filename = {URI(fn): fn for fn in items_by_filename.keys()}
    filename_to_uri = {fn: uri for uri, fn in uri_to_filename.items()}
    rset = load_metamodels(CLASS_DIAGRAM_MM, LEARNING_CORPUS_MM, MODELING_ASSISTANT_MM)
    resources = []
    for filename in items_by_filename.keys():
        resource: Resource = rset.create_resource(filename_to_uri[filename])
        resource.use_uuid = True
        resources.append(resource)
    for resource in resources:
        item = items = items_by_filename[uri_to_filename[resource.uri]]
        if isinstance(items, Iterable):
            resource.extend(items)
        else:
            resource.append(item)
    for resource in resources:
        resource.save()
