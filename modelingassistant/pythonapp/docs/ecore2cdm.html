<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ecore2cdm API documentation</title>
<meta name="description" content="Convert Ecore file(s) to TouchCORE class diagram (cdm) format â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ecore2cdm</code></h1>
</header>
<section id="section-intro">
<p>Convert Ecore file(s) to TouchCORE class diagram (cdm) format.</p>
<p>Author: Younes Boubekeur</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Convert Ecore file(s) to TouchCORE class diagram (cdm) format.

Author: Younes Boubekeur
&#34;&#34;&#34;

import difflib
import re
import os
import string
import sys

from pyecore.ecore import EAttribute, EClass, EDataType, EObject, EPackage, EReference
from pyecore.resources import ResourceSet, URI
from pyecore.valuecontainer import PyEcoreValue

from classdiagram import (Association, AssociationEnd, Attribute, CDAny, CDBoolean, CDDouble, CDEnum, CDEnumLiteral,
                          CDFloat, CDInt, CDLong, CDString, Class, ClassDiagram, Classifier)
from fileserdes import save_to_file
from utils import warn


# EDataType classes that must be not considered as enums
BASIC_CLASSES = {&#34;boolean&#34;, &#34;Date&#34;, &#34;DateTime&#34;, &#34;double&#34;, &#34;float&#34;, &#34;int&#34;, &#34;java.sql.Time&#34;, &#34;long&#34;, &#34;String&#34;, &#34;time&#34;}

ECORE_TYPE_NAMES_TO_CDM_TYPES: dict[str, type] = {
    &#34;EBoolean&#34;: CDBoolean,
    &#34;EDouble&#34;: CDDouble,
    &#34;EFloat&#34;: CDFloat,
    &#34;EInt&#34;: CDInt,
    &#34;ELong&#34;: CDLong,
    &#34;EString&#34;: CDString,
}


def load_ecore_model(ecore_file: str) -&gt; EPackage:
    &#34;Load the given ecore file into memory.&#34;
    rset = ResourceSet()
    resource = rset.get_resource(URI(ecore_file))
    mm_root = resource.contents[0]
    rset.metamodel_registry[mm_root.nsURI] = mm_root
    return mm_root


def convert(ecore_file: str) -&gt; ClassDiagram:
    &#34;Create a TouchCORE cdm file obtained by applying a model transformation on the input Ecore file.&#34;
    print(f&#34;Converting {ecore_file}&#34;)
    ecore_model = load_ecore_model(ecore_file)
    cdm = ClassDiagram(name=ecore_model.name)
    cdm_items: dict[str, EObject] = {ecore_model.name: cdm}  # track TC cdm items by name
    create_tc_builtin_types(cdm, cdm_items)
    for class_ in ecore_model.eClassifiers:
        match class_:
            case EDataType(name=enum_name, instanceClassName=icn) if icn not in BASIC_CLASSES:  # enum class
                enum = CDEnum(name=enum_name)
                cdm.types.append(enum)  # no classDiagram reference in its parts
                cdm_items[enum_name] = enum
            case EClass(name=cls_name):
                if cls_name in cdm_items and isinstance(cdm_items[cls_name], Classifier):
                    # class was added before as the opposite of a directed association
                    cls = cdm_items[cls_name]
                else:
                    cls = Class(name=cls_name)
                    cdm.classes.append(cls)
                    cdm_items[cls_name] = cls
                for sf in class_.eStructuralFeatures:
                    match sf:
                        case EAttribute(name=attr_name, eType=attr_type):
                            t = (cdm_items[attr_type.name] if attr_type and attr_type.name in cdm_items
                                 else cdm_items[&#34;CDAny&#34;])
                            attr = Attribute(name=attr_name, type=t)
                            cls.attributes.append(attr)
                            cdm_items[f&#34;{cls_name}.{attr_name}&#34;] = attr  # avoid clashes with other items
                        # when first added, all relationships are associations
                        case EReference(name=assocend_name, lowerBound=lb, upperBound=ub) as eref:
                            #print(f&#34;Creating AE for {cls_name}.{assocend_name}&#34;)
                            assocend = AssociationEnd(name=assocend_name, classifier=cls, lowerBound=lb, upperBound=ub,
                                                      assoc=assoc_for(eref, cdm, cdm_items))
                            cdm_items[f&#34;{cls_name}.{assocend_name}&#34;] = assocend
    ecore_file_base_name = ecore_file.removesuffix(&#39;.ecore&#39;)
    cdm = enhance_with_umple_file_info(ecore_model, cdm, cdm_items, f&#34;{ecore_file_base_name}.ump&#34;)
    save_to_file(f&#34;{ecore_file_base_name}.cdm&#34;, cdm)
    return cdm


def create_tc_builtin_types(cdm: ClassDiagram, cdm_items: dict[str, EObject]) -&gt; ClassDiagram:
    &#34;&#34;&#34;
    Create copies of the TouchCORE built-in types and add them to the given class diagram and dictionary.
    The class diagram is returned to allow for easier testing.
    &#34;&#34;&#34;
    for ecore_type_name, cd_type in ECORE_TYPE_NAMES_TO_CDM_TYPES.items():
        t = cd_type()  # create a new instance of the type for each submission
        cdm.types.append(t)
        cdm_items[ecore_type_name] = t
    # add non-primitive catch-all CDAny time to class diagram
    cd_any = CDAny()
    cdm.types.append(cd_any)
    cdm_items[&#34;CDAny&#34;] = cd_any
    return cdm


def assoc_for(eref: EReference, cdm: ClassDiagram, cdm_items: dict[str, EObject]) -&gt; Association:
    &#34;&#34;&#34;
    Return the correct TouchCORE class diagram association for the given EReference, creating it and adding it to the
    class diagram if necessary.
    &#34;&#34;&#34;
    def unique_name(eref):
        &#34;&#34;&#34;
        Return a unique name (enforced by case-sensitive alphabetical order) for the given EReference in the form
        &#34;A,B,a,b&#34;. For example, the reference (in Umple syntax)

        1 Car car -- * Wheel wheels;

        becomes &#34;Car,Wheel,car,wheel&#34;, since &#34;Car&#34; &lt; &#34;Wheel&#34;
        &#34;&#34;&#34;
        cls1, cls2 = sorted((eref.eContainingClass.name, eref.eType.name))
        # ensure that the order of the association ends is never flipped
        opposite_name = getattr(eref.eOpposite, &#34;name&#34;, &#34;&#34;)  # to support unidirectional associations
        if eref.eContainingClass.name &lt; eref.eType.name:
            ae1, ae2 = opposite_name, eref.name
        elif eref.eContainingClass.name &gt; eref.eType.name:
            ae1, ae2 = eref.name, opposite_name
        else:  # both class names are equal, so it&#39;s a reflexive association
            ae1, ae2 = sorted((eref.name, opposite_name))
        return &#34;,&#34;.join((cls1, cls2, ae1, ae2))

    name = unique_name(eref)
    if name not in cdm_items:
        tc_name = &#34;_&#34;.join(name.split(&#34;,&#34;)[:2])  # cls1_cls2, to match TouchCORE conventions
        assoc = Association(name=tc_name)
        cdm_items[name] = assoc
        cdm_items[tc_name] = assoc
        cdm.associations.append(assoc)
        if not eref.eOpposite:
            # add non-navigable TouchCORE association end here since it will not appear as an Ecore structural feature
            opposite_name = eref.eType.name
            cls_ref_name = lower_camel(eref.eContainingClass.name)
            if opposite_name in cdm_items and isinstance(cdm_items[opposite_name], Classifier):
                opposite_cls = cdm_items[opposite_name]
            else:
                opposite_cls = Class(name=opposite_name)
                cdm.classes.append(opposite_cls)
                cdm_items[opposite_name] = opposite_cls
            opposite_ae = AssociationEnd(name=cls_ref_name, classifier=opposite_cls, navigable=False, assoc=assoc)
            cdm_items[f&#34;{opposite_name}.{cls_ref_name}&#34;] = opposite_ae
    return cdm_items[name]


def enhance_with_umple_file_info(
    ecore_model: EPackage, cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_file: str) -&gt; ClassDiagram:
    &#34;&#34;&#34;
    Enhance the given TouchCORE diagram obtained from an Ecore file with additional information based on its source
    Umple file, if it exists.

    The following features are not converted automatically by Umple or not recognized by PyEcore and so must be scraped
    manually:

    - Composition
    - Class is abstract
    - Class is an interface, which also implies that superclasses need to be handled here
    - Enumeration items (Enumerations themselves are supported)
    &#34;&#34;&#34;
    if not os.path.isfile(umple_file):
        warn(f&#39;The file &#34;{umple_file}&#34; does not exist, so its CDM remains unchanged&#39;)
        return cdm
    with open(umple_file, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        umple_code = remove_umple_comments(f.read().split(&#34;//$?[End_of_model]$?&#34;)[0])
    umple_lines = [&#34;&#34;, *umple_code.splitlines()]  # Add a dummy &#34;line&#34; at the beginning to have 1-indexed lines
    if umple_lines[-1]:
        umple_lines.append(&#34;&#34;)  # always end with a newline
    cdm = add_compositions_to_cdm(cdm, cdm_items, umple_file, umple_lines)
    cdm, interfaces = set_abstract_classes_and_interfaces_in_cdm(cdm, cdm_items, umple_lines)
    cdm = add_generalizations_to_cdm(cdm, cdm_items, ecore_model, interfaces)
    cdm = add_enum_items_to_cdm(cdm, cdm_items, umple_lines, ecore_model)
    return cdm


def add_compositions_to_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_file: str, umple_lines: list[str]) -&gt; ClassDiagram:
    &#34;Detect compositions and add them to the given class diagram.&#34;

    def clean(s: str) -&gt; str:
        &#39;Clean string by replacing &#34;-&#34; with &#34; &#34; and removing numbers and special characters.&#39;
        return s.translate(str.maketrans(&#34;-&#34;, &#34; &#34;, f&#34;{string.digits}*.;{{}}&#34;)).strip()

    for i in range(1, len(umple_lines)):
        if &#34;&lt;@&gt;&#34; in umple_lines[i]:
            if &#34;&lt;@&gt;-&#34; in umple_lines[i]:
                &#34;&#34;&#34;
                Example:

                class Car {
                  1 car &lt;@&gt;- * Wheel wheels;
                }

                whole = Car, whole_refcls = Wheel.car, part = Wheel, part_refcls = Car.wheels
                &#34;&#34;&#34;
                before, after = clean(umple_lines[i]).split(&#34;&lt;@&gt;&#34;)
                after_split = after.split()
                whole = get_class_name(umple_lines, search_from_line=i)
                whole_refcls = cand if (cand := before.strip()).isidentifier() else lower_camel(whole)
                part = after_split[0].strip()
                if len(after_split) &gt; 1:
                    part_refcls = after_split[1].strip()
                else:
                    part_refcls = f&#34;{lower_camel(part)}s&#34;
                    if part.lower().endswith(&#34;status&#34;):
                        part_refcls = f&#34;{lower_camel(part)}es&#34;
                    # This warning is not needed for the final exam dataset since all improvisions have been checked,
                    # but is kept here to be used in the general case
                    #warn(&#34;Could not find a declared role name for composition part (part_refcls) for the composition &#34;
                    #     f&#34;{whole} &lt;@&gt;- {part}, so improvising with {part_refcls}&#34;)
            elif &#34;-&lt;@&gt;&#34; in umple_lines[i]:
                &#34;&#34;&#34;
                Example:

                class Wheel {
                  * wheels -&lt;@&gt; 1 Car car;
                }

                whole = Car, whole_refcls = Wheel.car, part = Wheel, part_refcls = Car.wheels
                &#34;&#34;&#34;
                before, after = clean(umple_lines[i]).split(&#34;&lt;@&gt;&#34;)
                after_split = after.split()
                whole = after_split[0].strip()
                whole_refcls = (cand if len(after_split) &gt; 1 and (cand := after_split[1].strip()).isidentifier()
                                else lower_camel(whole))
                part = get_class_name(umple_lines, search_from_line=i)
                if (cand := before.strip()).isidentifier():
                    part_refcls = cand
                else:
                    part_refcls = f&#34;{lower_camel(part)}s&#34;
                    if part.lower().endswith(&#34;status&#34;):
                        part_refcls = f&#34;{lower_camel(part)}es&#34;
                    # This warning is not needed for the final exam dataset since all improvisions have been checked,
                    # but is kept here to be used in the general case
                    #warn(&#34;Could not find a declared role name for composition part (part_refcls) for the composition &#34;
                    #     f&#34;{part} -&lt;@&gt; {whole}, so improvising with {part_refcls}&#34;)
            else:
                warn(f&#34;Invalid composition detected in {umple_file}&#34;)
            if whole &lt; part:
                assoc_name = &#34;,&#34;.join((whole, part, whole_refcls, part_refcls))
            elif whole &gt; part:
                assoc_name = &#34;,&#34;.join((part, whole, part_refcls, whole_refcls))
            else:
                warn(f&#34;Found reflexive association in {umple_file}: {whole} &lt;@&gt;- {part}&#34;)
                continue
            if assoc_name not in cdm_items:  # allow for minor variations
                assoc_name = next(iter(difflib.get_close_matches(assoc_name, cdm_items.keys(), n=1, cutoff=0.8)),
                                  assoc_name)
            if assoc_name in cdm_items:
                assoc: Association = cdm_items[assoc_name]
                # assume that each composition has exactly 2 ends
                composend: AssociationEnd = assoc.ends[0] if assoc.ends[0].classifier.name == whole else assoc.ends[1]
                composend.referenceType = &#34;Composition&#34;
            else:
                warn(f&#39;Could not find the &#34;{assoc_name}&#34; association in cdm_items dictionary&#39;)
    return cdm  # return cdm in helper functions to make them easier to test


def set_abstract_classes_and_interfaces_in_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_lines: list[str]) -&gt; tuple[ClassDiagram, set[Classifier]]:
    &#34;&#34;&#34;
    Set abstract classes and interfaces in the given TouchCORE class diagram and return a (class diagram, interfaces)
    tuple.
    &#34;&#34;&#34;
    interfaces: set[Classifier] = set()
    for i in range(1, len(umple_lines)):
        if &#34;abstract;&#34; in umple_lines[i]:
            class_name = get_class_name(umple_lines, search_from_line=i)
            if class_name in cdm_items:
                cls: Classifier = cdm_items[class_name]
                cls.abstract = True
        if &#34;interface;&#34; in umple_lines[i]:
            class_name = get_class_name(umple_lines, search_from_line=i)
            if class_name in cdm_items:
                cls: Classifier = cdm_items[class_name]
                cls.abstract = True
                interfaces.add(cls)
    return cdm, interfaces


def add_generalizations_to_cdm(cdm: ClassDiagram, cdm_items: dict[str, EObject], ecore_model: EPackage,
                               interfaces: set[Classifier]) -&gt; ClassDiagram:
    &#34;Detect generalizations and add them to the given TouchCORE class diagram.&#34;
    for cls in ecore_model.eClassifiers:
        if hasattr(cls, &#34;eSuperTypes&#34;):  # not an enum class
            for supercls in cls.eSuperTypes:
                if supercls.name not in interfaces:
                    cdm_items[cls.name].superTypes.append(cdm_items[supercls.name])
                    break
    return cdm


def add_enum_items_to_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_lines: list[str], ecore_model: EPackage) -&gt; ClassDiagram:
    &#34;Add enum items to the given TouchCORE class diagram.&#34;
    enums_from_ecore: list[str] = [cls.name for cls in ecore_model.eClassifiers
                                   if (isinstance(cls, EDataType) and cls.instanceClassName not in BASIC_CLASSES)]
    if not enums_from_ecore:
        return cdm  # no enums, so no enum items
    for i in range(1, len(umple_lines)):
        if &#34;enum&#34; in umple_lines[i]:
            j = i
            while j &lt; len(umple_lines):
                cd_enum: CDEnum = None
                ecore_enum = &#34;&#34;  # make linter happy
                for ecore_enum in enums_from_ecore:
                    k = j
                    while k &lt; len(umple_lines):  # check the enum on multiple lines, eg, enum E, enum\nE, etc
                        if ecore_enum in umple_lines[k]:
                            cd_enum = cdm_items[ecore_enum]
                        if cd_enum or &#34;}&#34; in umple_lines[k]:
                            break
                        k += 1
                    if cd_enum:
                        break
                if cd_enum:
                    k = j
                    while k &lt; len(umple_lines):
                        if &#34;}&#34; in umple_lines[k]:
                            break
                        k += 1
                    parts = (&#34; &#34;.join(umple_lines[j:k + 1]).replace(&#34;enum&#34;, &#34;&#34;).replace(ecore_enum, &#34;&#34;)
                             .replace(&#34;{&#34;, &#34;&#34;).replace(&#34;}&#34;, &#34;&#34;).replace(&#34;;&#34;, &#34;&#34;).split(&#34;,&#34;))
                    for s in parts:
                        r = s.strip()
                        if str.isidentifier(r):
                            if (qualified_enum_item_name := f&#34;{ecore_enum}.{r}&#34;) not in cdm_items:
                                enum_item = CDEnumLiteral(name=r)
                                cdm_items[qualified_enum_item_name] = enum_item
                                cd_enum.literals.append(enum_item)
                        else:
                            warn(f&#39;&#34;{r}&#34; does not appear to be a valid enum item for the enum {ecore_enum}&#39;)
                    if cd_enum.literals:
                        enums_from_ecore.remove(ecore_enum)
                if &#34;}&#34; in umple_lines[j]:
                    break
                j += 1
    if enums_from_ecore:
        warn(f&#34;Could not find enum literals for the enums {enums_from_ecore}&#34;)
    return cdm


def get_class_name(umple_lines: list[str], search_from_line: int) -&gt; str:
    &#34;Helper function to extract the class name immediately above the given line&#34;
    curr_line = search_from_line
    while curr_line:
        if umple_lines[curr_line].lstrip().startswith(&#34;class &#34;):
            return umple_lines[curr_line].replace(&#34;class &#34;, &#34;&#34;).split(&#34;{&#34;)[0].replace(&#34;}&#34;, &#34;&#34;).strip()
        curr_line -= 1
    warn(f&#34;Unable to return class name starting from line {search_from_line}&#34;)
    return &#34;&#34;


def lower_camel(s: str) -&gt; str:
    &#34;Return a string converted to lowerCamelCase.&#34;
    return f&#34;{s[0].lower()}{s[1:]}&#34;


def remove_umple_comments(umple_code: str):
    &#34;&#34;&#34;
    Remove Umple // and /**/ comments from the given Umple source code string.
    Adapted from stackoverflow.com/a/18234680.
    &#34;&#34;&#34;
    def replacer(match) :
        s = match.group(0)
        if s.startswith(&#39;/&#39;):  # s matches //... or /*...*/ so remove comment but preserving the number of newlines
            return &#34;&#34; + (&#34;\n&#34; * s.count(&#39;\n&#39;))
        else:  # Keep quoted string unchanged
            return s
    pattern = re.compile(r&#39;//.*?$|/\*.*?\*/|\&#39;(?:\\.|[^\\\&#39;])*\&#39;|&#34;(?:\\.|[^\\&#34;])*&#34;&#39;, re.DOTALL | re.MULTILINE)
    return re.sub(pattern, replacer, umple_code)


def init():
    &#34;Initial setup before running script.&#34;
    # Make PyEcore type checking more lenient when dealing with static student submissions that might be malformed
    # Doing this is not recommended in general
    PyEcoreValue.check = lambda *_: True


def main():
    &#34;Main entry point.&#34;
    init()
    if len(sys.argv) != 2:
        print(&#34;Usage: python ecore2cdm.py ecore_file_or_folder&#34;)
        sys.exit(1)
    arg = sys.argv[1]
    if arg.lower().endswith(&#34;.ecore&#34;):
        convert(arg)
    elif os.path.isdir(arg):
        for file_ in os.listdir(arg):
            if file_.lower().endswith(&#34;.ecore&#34;):
                convert(os.path.join(arg, file_))
    else:
        print(&#34;Error: argument is not an ecore file or a valid directory&#34;)
        sys.exit(1)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ecore2cdm.add_compositions_to_cdm"><code class="name flex">
<span>def <span class="ident">add_compositions_to_cdm</span></span>(<span>cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject], umple_file:Â str, umple_lines:Â list[str]) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Detect compositions and add them to the given class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_compositions_to_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_file: str, umple_lines: list[str]) -&gt; ClassDiagram:
    &#34;Detect compositions and add them to the given class diagram.&#34;

    def clean(s: str) -&gt; str:
        &#39;Clean string by replacing &#34;-&#34; with &#34; &#34; and removing numbers and special characters.&#39;
        return s.translate(str.maketrans(&#34;-&#34;, &#34; &#34;, f&#34;{string.digits}*.;{{}}&#34;)).strip()

    for i in range(1, len(umple_lines)):
        if &#34;&lt;@&gt;&#34; in umple_lines[i]:
            if &#34;&lt;@&gt;-&#34; in umple_lines[i]:
                &#34;&#34;&#34;
                Example:

                class Car {
                  1 car &lt;@&gt;- * Wheel wheels;
                }

                whole = Car, whole_refcls = Wheel.car, part = Wheel, part_refcls = Car.wheels
                &#34;&#34;&#34;
                before, after = clean(umple_lines[i]).split(&#34;&lt;@&gt;&#34;)
                after_split = after.split()
                whole = get_class_name(umple_lines, search_from_line=i)
                whole_refcls = cand if (cand := before.strip()).isidentifier() else lower_camel(whole)
                part = after_split[0].strip()
                if len(after_split) &gt; 1:
                    part_refcls = after_split[1].strip()
                else:
                    part_refcls = f&#34;{lower_camel(part)}s&#34;
                    if part.lower().endswith(&#34;status&#34;):
                        part_refcls = f&#34;{lower_camel(part)}es&#34;
                    # This warning is not needed for the final exam dataset since all improvisions have been checked,
                    # but is kept here to be used in the general case
                    #warn(&#34;Could not find a declared role name for composition part (part_refcls) for the composition &#34;
                    #     f&#34;{whole} &lt;@&gt;- {part}, so improvising with {part_refcls}&#34;)
            elif &#34;-&lt;@&gt;&#34; in umple_lines[i]:
                &#34;&#34;&#34;
                Example:

                class Wheel {
                  * wheels -&lt;@&gt; 1 Car car;
                }

                whole = Car, whole_refcls = Wheel.car, part = Wheel, part_refcls = Car.wheels
                &#34;&#34;&#34;
                before, after = clean(umple_lines[i]).split(&#34;&lt;@&gt;&#34;)
                after_split = after.split()
                whole = after_split[0].strip()
                whole_refcls = (cand if len(after_split) &gt; 1 and (cand := after_split[1].strip()).isidentifier()
                                else lower_camel(whole))
                part = get_class_name(umple_lines, search_from_line=i)
                if (cand := before.strip()).isidentifier():
                    part_refcls = cand
                else:
                    part_refcls = f&#34;{lower_camel(part)}s&#34;
                    if part.lower().endswith(&#34;status&#34;):
                        part_refcls = f&#34;{lower_camel(part)}es&#34;
                    # This warning is not needed for the final exam dataset since all improvisions have been checked,
                    # but is kept here to be used in the general case
                    #warn(&#34;Could not find a declared role name for composition part (part_refcls) for the composition &#34;
                    #     f&#34;{part} -&lt;@&gt; {whole}, so improvising with {part_refcls}&#34;)
            else:
                warn(f&#34;Invalid composition detected in {umple_file}&#34;)
            if whole &lt; part:
                assoc_name = &#34;,&#34;.join((whole, part, whole_refcls, part_refcls))
            elif whole &gt; part:
                assoc_name = &#34;,&#34;.join((part, whole, part_refcls, whole_refcls))
            else:
                warn(f&#34;Found reflexive association in {umple_file}: {whole} &lt;@&gt;- {part}&#34;)
                continue
            if assoc_name not in cdm_items:  # allow for minor variations
                assoc_name = next(iter(difflib.get_close_matches(assoc_name, cdm_items.keys(), n=1, cutoff=0.8)),
                                  assoc_name)
            if assoc_name in cdm_items:
                assoc: Association = cdm_items[assoc_name]
                # assume that each composition has exactly 2 ends
                composend: AssociationEnd = assoc.ends[0] if assoc.ends[0].classifier.name == whole else assoc.ends[1]
                composend.referenceType = &#34;Composition&#34;
            else:
                warn(f&#39;Could not find the &#34;{assoc_name}&#34; association in cdm_items dictionary&#39;)
    return cdm  # return cdm in helper functions to make them easier to test</code></pre>
</details>
</dd>
<dt id="ecore2cdm.add_enum_items_to_cdm"><code class="name flex">
<span>def <span class="ident">add_enum_items_to_cdm</span></span>(<span>cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject], umple_lines:Â list[str], ecore_model:Â pyecore.ecore.EPackage) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add enum items to the given TouchCORE class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_enum_items_to_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_lines: list[str], ecore_model: EPackage) -&gt; ClassDiagram:
    &#34;Add enum items to the given TouchCORE class diagram.&#34;
    enums_from_ecore: list[str] = [cls.name for cls in ecore_model.eClassifiers
                                   if (isinstance(cls, EDataType) and cls.instanceClassName not in BASIC_CLASSES)]
    if not enums_from_ecore:
        return cdm  # no enums, so no enum items
    for i in range(1, len(umple_lines)):
        if &#34;enum&#34; in umple_lines[i]:
            j = i
            while j &lt; len(umple_lines):
                cd_enum: CDEnum = None
                ecore_enum = &#34;&#34;  # make linter happy
                for ecore_enum in enums_from_ecore:
                    k = j
                    while k &lt; len(umple_lines):  # check the enum on multiple lines, eg, enum E, enum\nE, etc
                        if ecore_enum in umple_lines[k]:
                            cd_enum = cdm_items[ecore_enum]
                        if cd_enum or &#34;}&#34; in umple_lines[k]:
                            break
                        k += 1
                    if cd_enum:
                        break
                if cd_enum:
                    k = j
                    while k &lt; len(umple_lines):
                        if &#34;}&#34; in umple_lines[k]:
                            break
                        k += 1
                    parts = (&#34; &#34;.join(umple_lines[j:k + 1]).replace(&#34;enum&#34;, &#34;&#34;).replace(ecore_enum, &#34;&#34;)
                             .replace(&#34;{&#34;, &#34;&#34;).replace(&#34;}&#34;, &#34;&#34;).replace(&#34;;&#34;, &#34;&#34;).split(&#34;,&#34;))
                    for s in parts:
                        r = s.strip()
                        if str.isidentifier(r):
                            if (qualified_enum_item_name := f&#34;{ecore_enum}.{r}&#34;) not in cdm_items:
                                enum_item = CDEnumLiteral(name=r)
                                cdm_items[qualified_enum_item_name] = enum_item
                                cd_enum.literals.append(enum_item)
                        else:
                            warn(f&#39;&#34;{r}&#34; does not appear to be a valid enum item for the enum {ecore_enum}&#39;)
                    if cd_enum.literals:
                        enums_from_ecore.remove(ecore_enum)
                if &#34;}&#34; in umple_lines[j]:
                    break
                j += 1
    if enums_from_ecore:
        warn(f&#34;Could not find enum literals for the enums {enums_from_ecore}&#34;)
    return cdm</code></pre>
</details>
</dd>
<dt id="ecore2cdm.add_generalizations_to_cdm"><code class="name flex">
<span>def <span class="ident">add_generalizations_to_cdm</span></span>(<span>cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject], ecore_model:Â pyecore.ecore.EPackage, interfaces:Â set[<a title="classdiagram.classdiagram.Classifier" href="classdiagram/classdiagram.html#classdiagram.classdiagram.Classifier">Classifier</a>]) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Detect generalizations and add them to the given TouchCORE class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_generalizations_to_cdm(cdm: ClassDiagram, cdm_items: dict[str, EObject], ecore_model: EPackage,
                               interfaces: set[Classifier]) -&gt; ClassDiagram:
    &#34;Detect generalizations and add them to the given TouchCORE class diagram.&#34;
    for cls in ecore_model.eClassifiers:
        if hasattr(cls, &#34;eSuperTypes&#34;):  # not an enum class
            for supercls in cls.eSuperTypes:
                if supercls.name not in interfaces:
                    cdm_items[cls.name].superTypes.append(cdm_items[supercls.name])
                    break
    return cdm</code></pre>
</details>
</dd>
<dt id="ecore2cdm.assoc_for"><code class="name flex">
<span>def <span class="ident">assoc_for</span></span>(<span>eref:Â pyecore.ecore.EReference, cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject]) â€‘>Â <a title="classdiagram.classdiagram.Association" href="classdiagram/classdiagram.html#classdiagram.classdiagram.Association">Association</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the correct TouchCORE class diagram association for the given EReference, creating it and adding it to the
class diagram if necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assoc_for(eref: EReference, cdm: ClassDiagram, cdm_items: dict[str, EObject]) -&gt; Association:
    &#34;&#34;&#34;
    Return the correct TouchCORE class diagram association for the given EReference, creating it and adding it to the
    class diagram if necessary.
    &#34;&#34;&#34;
    def unique_name(eref):
        &#34;&#34;&#34;
        Return a unique name (enforced by case-sensitive alphabetical order) for the given EReference in the form
        &#34;A,B,a,b&#34;. For example, the reference (in Umple syntax)

        1 Car car -- * Wheel wheels;

        becomes &#34;Car,Wheel,car,wheel&#34;, since &#34;Car&#34; &lt; &#34;Wheel&#34;
        &#34;&#34;&#34;
        cls1, cls2 = sorted((eref.eContainingClass.name, eref.eType.name))
        # ensure that the order of the association ends is never flipped
        opposite_name = getattr(eref.eOpposite, &#34;name&#34;, &#34;&#34;)  # to support unidirectional associations
        if eref.eContainingClass.name &lt; eref.eType.name:
            ae1, ae2 = opposite_name, eref.name
        elif eref.eContainingClass.name &gt; eref.eType.name:
            ae1, ae2 = eref.name, opposite_name
        else:  # both class names are equal, so it&#39;s a reflexive association
            ae1, ae2 = sorted((eref.name, opposite_name))
        return &#34;,&#34;.join((cls1, cls2, ae1, ae2))

    name = unique_name(eref)
    if name not in cdm_items:
        tc_name = &#34;_&#34;.join(name.split(&#34;,&#34;)[:2])  # cls1_cls2, to match TouchCORE conventions
        assoc = Association(name=tc_name)
        cdm_items[name] = assoc
        cdm_items[tc_name] = assoc
        cdm.associations.append(assoc)
        if not eref.eOpposite:
            # add non-navigable TouchCORE association end here since it will not appear as an Ecore structural feature
            opposite_name = eref.eType.name
            cls_ref_name = lower_camel(eref.eContainingClass.name)
            if opposite_name in cdm_items and isinstance(cdm_items[opposite_name], Classifier):
                opposite_cls = cdm_items[opposite_name]
            else:
                opposite_cls = Class(name=opposite_name)
                cdm.classes.append(opposite_cls)
                cdm_items[opposite_name] = opposite_cls
            opposite_ae = AssociationEnd(name=cls_ref_name, classifier=opposite_cls, navigable=False, assoc=assoc)
            cdm_items[f&#34;{opposite_name}.{cls_ref_name}&#34;] = opposite_ae
    return cdm_items[name]</code></pre>
</details>
</dd>
<dt id="ecore2cdm.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>ecore_file:Â str) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a TouchCORE cdm file obtained by applying a model transformation on the input Ecore file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(ecore_file: str) -&gt; ClassDiagram:
    &#34;Create a TouchCORE cdm file obtained by applying a model transformation on the input Ecore file.&#34;
    print(f&#34;Converting {ecore_file}&#34;)
    ecore_model = load_ecore_model(ecore_file)
    cdm = ClassDiagram(name=ecore_model.name)
    cdm_items: dict[str, EObject] = {ecore_model.name: cdm}  # track TC cdm items by name
    create_tc_builtin_types(cdm, cdm_items)
    for class_ in ecore_model.eClassifiers:
        match class_:
            case EDataType(name=enum_name, instanceClassName=icn) if icn not in BASIC_CLASSES:  # enum class
                enum = CDEnum(name=enum_name)
                cdm.types.append(enum)  # no classDiagram reference in its parts
                cdm_items[enum_name] = enum
            case EClass(name=cls_name):
                if cls_name in cdm_items and isinstance(cdm_items[cls_name], Classifier):
                    # class was added before as the opposite of a directed association
                    cls = cdm_items[cls_name]
                else:
                    cls = Class(name=cls_name)
                    cdm.classes.append(cls)
                    cdm_items[cls_name] = cls
                for sf in class_.eStructuralFeatures:
                    match sf:
                        case EAttribute(name=attr_name, eType=attr_type):
                            t = (cdm_items[attr_type.name] if attr_type and attr_type.name in cdm_items
                                 else cdm_items[&#34;CDAny&#34;])
                            attr = Attribute(name=attr_name, type=t)
                            cls.attributes.append(attr)
                            cdm_items[f&#34;{cls_name}.{attr_name}&#34;] = attr  # avoid clashes with other items
                        # when first added, all relationships are associations
                        case EReference(name=assocend_name, lowerBound=lb, upperBound=ub) as eref:
                            #print(f&#34;Creating AE for {cls_name}.{assocend_name}&#34;)
                            assocend = AssociationEnd(name=assocend_name, classifier=cls, lowerBound=lb, upperBound=ub,
                                                      assoc=assoc_for(eref, cdm, cdm_items))
                            cdm_items[f&#34;{cls_name}.{assocend_name}&#34;] = assocend
    ecore_file_base_name = ecore_file.removesuffix(&#39;.ecore&#39;)
    cdm = enhance_with_umple_file_info(ecore_model, cdm, cdm_items, f&#34;{ecore_file_base_name}.ump&#34;)
    save_to_file(f&#34;{ecore_file_base_name}.cdm&#34;, cdm)
    return cdm</code></pre>
</details>
</dd>
<dt id="ecore2cdm.create_tc_builtin_types"><code class="name flex">
<span>def <span class="ident">create_tc_builtin_types</span></span>(<span>cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject]) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create copies of the TouchCORE built-in types and add them to the given class diagram and dictionary.
The class diagram is returned to allow for easier testing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tc_builtin_types(cdm: ClassDiagram, cdm_items: dict[str, EObject]) -&gt; ClassDiagram:
    &#34;&#34;&#34;
    Create copies of the TouchCORE built-in types and add them to the given class diagram and dictionary.
    The class diagram is returned to allow for easier testing.
    &#34;&#34;&#34;
    for ecore_type_name, cd_type in ECORE_TYPE_NAMES_TO_CDM_TYPES.items():
        t = cd_type()  # create a new instance of the type for each submission
        cdm.types.append(t)
        cdm_items[ecore_type_name] = t
    # add non-primitive catch-all CDAny time to class diagram
    cd_any = CDAny()
    cdm.types.append(cd_any)
    cdm_items[&#34;CDAny&#34;] = cd_any
    return cdm</code></pre>
</details>
</dd>
<dt id="ecore2cdm.enhance_with_umple_file_info"><code class="name flex">
<span>def <span class="ident">enhance_with_umple_file_info</span></span>(<span>ecore_model:Â pyecore.ecore.EPackage, cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject], umple_file:Â str) â€‘>Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Enhance the given TouchCORE diagram obtained from an Ecore file with additional information based on its source
Umple file, if it exists.</p>
<p>The following features are not converted automatically by Umple or not recognized by PyEcore and so must be scraped
manually:</p>
<ul>
<li>Composition</li>
<li>Class is abstract</li>
<li>Class is an interface, which also implies that superclasses need to be handled here</li>
<li>Enumeration items (Enumerations themselves are supported)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enhance_with_umple_file_info(
    ecore_model: EPackage, cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_file: str) -&gt; ClassDiagram:
    &#34;&#34;&#34;
    Enhance the given TouchCORE diagram obtained from an Ecore file with additional information based on its source
    Umple file, if it exists.

    The following features are not converted automatically by Umple or not recognized by PyEcore and so must be scraped
    manually:

    - Composition
    - Class is abstract
    - Class is an interface, which also implies that superclasses need to be handled here
    - Enumeration items (Enumerations themselves are supported)
    &#34;&#34;&#34;
    if not os.path.isfile(umple_file):
        warn(f&#39;The file &#34;{umple_file}&#34; does not exist, so its CDM remains unchanged&#39;)
        return cdm
    with open(umple_file, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        umple_code = remove_umple_comments(f.read().split(&#34;//$?[End_of_model]$?&#34;)[0])
    umple_lines = [&#34;&#34;, *umple_code.splitlines()]  # Add a dummy &#34;line&#34; at the beginning to have 1-indexed lines
    if umple_lines[-1]:
        umple_lines.append(&#34;&#34;)  # always end with a newline
    cdm = add_compositions_to_cdm(cdm, cdm_items, umple_file, umple_lines)
    cdm, interfaces = set_abstract_classes_and_interfaces_in_cdm(cdm, cdm_items, umple_lines)
    cdm = add_generalizations_to_cdm(cdm, cdm_items, ecore_model, interfaces)
    cdm = add_enum_items_to_cdm(cdm, cdm_items, umple_lines, ecore_model)
    return cdm</code></pre>
</details>
</dd>
<dt id="ecore2cdm.get_class_name"><code class="name flex">
<span>def <span class="ident">get_class_name</span></span>(<span>umple_lines:Â list[str], search_from_line:Â int) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to extract the class name immediately above the given line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_name(umple_lines: list[str], search_from_line: int) -&gt; str:
    &#34;Helper function to extract the class name immediately above the given line&#34;
    curr_line = search_from_line
    while curr_line:
        if umple_lines[curr_line].lstrip().startswith(&#34;class &#34;):
            return umple_lines[curr_line].replace(&#34;class &#34;, &#34;&#34;).split(&#34;{&#34;)[0].replace(&#34;}&#34;, &#34;&#34;).strip()
        curr_line -= 1
    warn(f&#34;Unable to return class name starting from line {search_from_line}&#34;)
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="ecore2cdm.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial setup before running script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init():
    &#34;Initial setup before running script.&#34;
    # Make PyEcore type checking more lenient when dealing with static student submissions that might be malformed
    # Doing this is not recommended in general
    PyEcoreValue.check = lambda *_: True</code></pre>
</details>
</dd>
<dt id="ecore2cdm.load_ecore_model"><code class="name flex">
<span>def <span class="ident">load_ecore_model</span></span>(<span>ecore_file:Â str) â€‘>Â pyecore.ecore.EPackage</span>
</code></dt>
<dd>
<div class="desc"><p>Load the given ecore file into memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_ecore_model(ecore_file: str) -&gt; EPackage:
    &#34;Load the given ecore file into memory.&#34;
    rset = ResourceSet()
    resource = rset.get_resource(URI(ecore_file))
    mm_root = resource.contents[0]
    rset.metamodel_registry[mm_root.nsURI] = mm_root
    return mm_root</code></pre>
</details>
</dd>
<dt id="ecore2cdm.lower_camel"><code class="name flex">
<span>def <span class="ident">lower_camel</span></span>(<span>s:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a string converted to lowerCamelCase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lower_camel(s: str) -&gt; str:
    &#34;Return a string converted to lowerCamelCase.&#34;
    return f&#34;{s[0].lower()}{s[1:]}&#34;</code></pre>
</details>
</dd>
<dt id="ecore2cdm.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main entry point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;Main entry point.&#34;
    init()
    if len(sys.argv) != 2:
        print(&#34;Usage: python ecore2cdm.py ecore_file_or_folder&#34;)
        sys.exit(1)
    arg = sys.argv[1]
    if arg.lower().endswith(&#34;.ecore&#34;):
        convert(arg)
    elif os.path.isdir(arg):
        for file_ in os.listdir(arg):
            if file_.lower().endswith(&#34;.ecore&#34;):
                convert(os.path.join(arg, file_))
    else:
        print(&#34;Error: argument is not an ecore file or a valid directory&#34;)
        sys.exit(1)</code></pre>
</details>
</dd>
<dt id="ecore2cdm.remove_umple_comments"><code class="name flex">
<span>def <span class="ident">remove_umple_comments</span></span>(<span>umple_code:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove Umple // and /**/ comments from the given Umple source code string.
Adapted from stackoverflow.com/a/18234680.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_umple_comments(umple_code: str):
    &#34;&#34;&#34;
    Remove Umple // and /**/ comments from the given Umple source code string.
    Adapted from stackoverflow.com/a/18234680.
    &#34;&#34;&#34;
    def replacer(match) :
        s = match.group(0)
        if s.startswith(&#39;/&#39;):  # s matches //... or /*...*/ so remove comment but preserving the number of newlines
            return &#34;&#34; + (&#34;\n&#34; * s.count(&#39;\n&#39;))
        else:  # Keep quoted string unchanged
            return s
    pattern = re.compile(r&#39;//.*?$|/\*.*?\*/|\&#39;(?:\\.|[^\\\&#39;])*\&#39;|&#34;(?:\\.|[^\\&#34;])*&#34;&#39;, re.DOTALL | re.MULTILINE)
    return re.sub(pattern, replacer, umple_code)</code></pre>
</details>
</dd>
<dt id="ecore2cdm.set_abstract_classes_and_interfaces_in_cdm"><code class="name flex">
<span>def <span class="ident">set_abstract_classes_and_interfaces_in_cdm</span></span>(<span>cdm:Â <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, cdm_items:Â dict[str,Â pyecore.ecore.EObject], umple_lines:Â list[str]) â€‘>Â tuple[<a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>,Â set[<a title="classdiagram.classdiagram.Classifier" href="classdiagram/classdiagram.html#classdiagram.classdiagram.Classifier">Classifier</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Set abstract classes and interfaces in the given TouchCORE class diagram and return a (class diagram, interfaces)
tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_abstract_classes_and_interfaces_in_cdm(
    cdm: ClassDiagram, cdm_items: dict[str, EObject], umple_lines: list[str]) -&gt; tuple[ClassDiagram, set[Classifier]]:
    &#34;&#34;&#34;
    Set abstract classes and interfaces in the given TouchCORE class diagram and return a (class diagram, interfaces)
    tuple.
    &#34;&#34;&#34;
    interfaces: set[Classifier] = set()
    for i in range(1, len(umple_lines)):
        if &#34;abstract;&#34; in umple_lines[i]:
            class_name = get_class_name(umple_lines, search_from_line=i)
            if class_name in cdm_items:
                cls: Classifier = cdm_items[class_name]
                cls.abstract = True
        if &#34;interface;&#34; in umple_lines[i]:
            class_name = get_class_name(umple_lines, search_from_line=i)
            if class_name in cdm_items:
                cls: Classifier = cdm_items[class_name]
                cls.abstract = True
                interfaces.add(cls)
    return cdm, interfaces</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ecore2cdm.add_compositions_to_cdm" href="#ecore2cdm.add_compositions_to_cdm">add_compositions_to_cdm</a></code></li>
<li><code><a title="ecore2cdm.add_enum_items_to_cdm" href="#ecore2cdm.add_enum_items_to_cdm">add_enum_items_to_cdm</a></code></li>
<li><code><a title="ecore2cdm.add_generalizations_to_cdm" href="#ecore2cdm.add_generalizations_to_cdm">add_generalizations_to_cdm</a></code></li>
<li><code><a title="ecore2cdm.assoc_for" href="#ecore2cdm.assoc_for">assoc_for</a></code></li>
<li><code><a title="ecore2cdm.convert" href="#ecore2cdm.convert">convert</a></code></li>
<li><code><a title="ecore2cdm.create_tc_builtin_types" href="#ecore2cdm.create_tc_builtin_types">create_tc_builtin_types</a></code></li>
<li><code><a title="ecore2cdm.enhance_with_umple_file_info" href="#ecore2cdm.enhance_with_umple_file_info">enhance_with_umple_file_info</a></code></li>
<li><code><a title="ecore2cdm.get_class_name" href="#ecore2cdm.get_class_name">get_class_name</a></code></li>
<li><code><a title="ecore2cdm.init" href="#ecore2cdm.init">init</a></code></li>
<li><code><a title="ecore2cdm.load_ecore_model" href="#ecore2cdm.load_ecore_model">load_ecore_model</a></code></li>
<li><code><a title="ecore2cdm.lower_camel" href="#ecore2cdm.lower_camel">lower_camel</a></code></li>
<li><code><a title="ecore2cdm.main" href="#ecore2cdm.main">main</a></code></li>
<li><code><a title="ecore2cdm.remove_umple_comments" href="#ecore2cdm.remove_umple_comments">remove_umple_comments</a></code></li>
<li><code><a title="ecore2cdm.set_abstract_classes_and_interfaces_in_cdm" href="#ecore2cdm.set_abstract_classes_and_interfaces_in_cdm">set_abstract_classes_and_interfaces_in_cdm</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>