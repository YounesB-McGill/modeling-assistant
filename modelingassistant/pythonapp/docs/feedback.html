<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>feedback API documentation</title>
<meta name="description" content="Module containing feedback algorithm for modeling assistant." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>feedback</code></h1>
</header>
<section id="section-intro">
<p>Module containing feedback algorithm for modeling assistant.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Module containing feedback algorithm for modeling assistant.
&#34;&#34;&#34;

from collections.abc import Iterable
from dataclasses import dataclass, field
from functools import cache
import logging

from ordered_set import OrderedSet

import modelingassistantapp
from classdiagram import ClassDiagram, NamedElement
from color import Color
from corpusdefinition import infinite_recursive_dependency, missing_multiplicity
from modelingassistantapp import MODELING_ASSISTANT, get_mistakes
from parametrizedresponse import comma_seperated_with_and, parametrize_response
from serdes import set_static_class_for
from stringserdes import str_to_cdm
from utils import quote, warn
from learningcorpus import Feedback, LearningResource, ParametrizedResponse, ResourceResponse, TextResponse
from modelingassistant import (ModelingAssistant, Student, ProblemStatement, FeedbackItem, Mistake, Solution,
                               SolutionElement, StudentKnowledge)


logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

MAX_STUDENT_LEVEL_OF_KNOWLEDGE = 10.0
BEGINNER_LEVEL_OF_KNOWLEDGE = 7.0


DEFAULT_HIGHLIGHT_COLOR = Color.LIGHT_YELLOW

_empty_resource = LearningResource(name=&#34;Empty&#34;, content=&#34;&#34;)


@dataclass
class FeedbackTO:
    &#34;&#34;&#34;
    Feedback transfer object class. An explicit class is used to allow for lint and compile-time type checking.

    When transformed to JSON, this object will have the following structure:

    ```json
    {
        &#34;grade&#34;: 0.0,
        &#34;problemStatementElements&#34;: {&#34;#fffacd&#34;: [&#34;7&#34;, &#34;8&#34;, &#34;9&#34;]},
        &#34;solutionElements&#34;: {&#34;#add8e6&#34;: [ &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;]},
        &#34;writtenFeedback&#34;: &#34;The hex strings above refer to the colors used to highlight the diagram elements.&#34;
    }
    ```
    &#34;&#34;&#34;
    # pylint: disable=invalid-name, protected-access
    solutionElements: dict[str, list[str]] = field(default_factory=dict)  # includes generalizations
    problemStatementElements: dict[str, list[str]] = field(default_factory=dict)
    grade: float = 0.0
    writtenFeedback: str = &#34;&#34;

    # custom __init__ for correct JSON (de)serialization
    def __init__(self, solutionElements: dict[str, list[str]] = field(default_factory=dict),
                 problemStatementElements: dict[str, list[str]] = field(default_factory=dict),
                 grade: float = 0.0, writtenFeedback: str = &#34;&#34;, feedback: FeedbackItem = None):
        # pylint: disable=too-many-arguments
        def make_highlighted_elems(
            elems: Iterable[str] | Iterable[NamedElement] | Iterable[SolutionElement]
                 | dict[str, list[str] | list[NamedElement] | list[SolutionElement]]) -&gt; dict[str, list[str]]:
            def id_for(e: str | NamedElement | SolutionElement) -&gt; str:
                if not isinstance(e, str | NamedElement | SolutionElement):
                    raise TypeError(f&#34;Expected str, NamedElement, or SolutionElement but got {e} of type {type(e)}&#34;)
                return e.element._internal_id if isinstance(e, SolutionElement) else (
                    e._internal_id if isinstance(e, NamedElement) else e)
            if not elems:
                return {}
            if isinstance(elems, list | OrderedSet):
                return {DEFAULT_HIGHLIGHT_COLOR.to_hex(): [id_for(e) for e in elems]}
            if isinstance(elems, dict):
                return {color: [id_for(e) for e in elems[color]] for color in elems}
            raise TypeError(f&#34;Unexpected type elems type: {type(elems)}&#34;)

        def get_ids(elems: dict[str, list[str]]) -&gt; list[str]:
            result = set()
            for ids in elems.values():
                result.update(ids)
            return list(result)

        if feedback:
            solutionElements: OrderedSet[SolutionElement] = feedback.mistake.studentElements
            problemStatementElements: OrderedSet[SolutionElement] = feedback.mistake.instructorElements
            writtenFeedback = verbalize_feedback_description(feedback)
        self.solutionElements = make_highlighted_elems(solutionElements)
        self.solutionElementIds = get_ids(self.solutionElements)
        self.problemStatementElements = make_highlighted_elems(problemStatementElements)
        self.problemStatementElementIds = get_ids(self.problemStatementElements)
        self.grade = grade
        self.writtenFeedback = writtenFeedback


def give_feedback(student_solution: Solution) -&gt; FeedbackItem | list[FeedbackItem]:
    &#34;Give feedback on the given student solution.&#34;
    if student_solution is not student_solution.student.currentSolution:
        pass  # return None  # do not give feedback for other unrelated solutions
    if not student_solution.mistakes:
        # emoji to test serdes
        return FeedbackItem(feedback=TextResponse(text=&#34;All good, no mistakes found! 🎉&#34;), solution=student_solution)

    # sort mistakes by priority and filter out mistakes which are already resolved
    unresolved_mistakes: list[Mistake] = [
        m for m in sorted(student_solution.mistakes, key=lambda m: m.mistakeType.priority) if not m.resolvedByStudent]

    # update student knowledge for each unresolved mistake type
    for m in unresolved_mistakes:
        student_knowledge_for(m).levelOfKnowledge = MAX_STUDENT_LEVEL_OF_KNOWLEDGE - m.numDetections

    # sort highest priority mistakes based on number of detections (start with those detected the most times)
    highest_priority = unresolved_mistakes[0].mistakeType.priority
    highest_priority_mistakes = sorted([m for m in unresolved_mistakes if m.mistakeType.priority == highest_priority],
                                       key=lambda m: m.numDetections, reverse=True)

    result: list[FeedbackItem] = []

    for m in highest_priority_mistakes:
        #student_solution.currentMistake = m  # TODO
        result.append(next_feedback(m))
        # decide whether student is beginner overall
        if student_knowledge_for(m).levelOfKnowledge &lt; BEGINNER_LEVEL_OF_KNOWLEDGE:
            break

    resolved_mistakes: list[Mistake] = [m for m in student_solution.mistakes if m.resolvedByStudent]
    for m in resolved_mistakes:
        if sk := student_knowledge_for(m):
            if m.lastFeedback: # ignore mistakes which have been resolved before feedback was given on them
                sk.levelOfKnowledge += m.lastFeedback.feedback.level / 2

    return result[0] if len(result) == 1 else result


def next_feedback(mistake: Mistake) -&gt; FeedbackItem:
    &#34;&#34;&#34;
    Return the feedback item at the next level for the given mistake, eg,

        next_feedback(mistake with lastFeedback.level = 2) = feedback at level 3
    &#34;&#34;&#34;
    target_level = mistake.lastFeedback.feedback.level + 1 if mistake.lastFeedback else 1
    next_fb: Feedback = set_static_class_for(
        next(fb for fb in mistake.mistakeType.feedbacks if fb.level == target_level))
    fb_text = next_fb.text
    if isinstance(next_fb, ParametrizedResponse):
        fb_text = parametrize_response(next_fb, mistake)
    return FeedbackItem(text=fb_text, feedback=next_fb, solution=mistake.solution, mistake=mistake)


def student_knowledge_for(mistake: Mistake) -&gt; StudentKnowledge:
    &#34;&#34;&#34;
    Return the student knowledge object for the given mistake (a mistake is made by a specific student).
    If not found, create a new one.
    &#34;&#34;&#34;
    # pylint: disable=protected-access
    # TODO Cache studentknowledges or redesign metamodel to access them in O(1) time instead of O(n)
    student = mistake.solution.student
    # print statements for debugging, will be cleaned up later
    #print(&#34;Student knowledges for&#34;, student.name, &#34;Mistake&#34;, mistake.mistakeType.name,mistake.mistakeType._internal_id)
    for sk in student.studentKnowledges:
        #print(&#34;&gt;&gt;&gt;&#34;, sk.mistakeType.name, sk.mistakeType._internal_id, sk.levelOfKnowledge)
        if sk.mistakeType._internal_id == mistake.mistakeType._internal_id:
            #print(&#34;--- Returning existing SK\n&#34;)
            return sk
    #print(f&#34;** Creating new SK for mistake type {mistake.mistakeType.name} ({mistake.mistakeType._internal_id}) **\n&#34;)
    return StudentKnowledge(student=student, mistakeType=mistake.mistakeType, levelOfKnowledge=5.0,
                            modelingAssistant=mistake.solution.modelingAssistant)


def give_feedback_for_student_cdm(username: str, student_cdm: ClassDiagram | str, ma: ModelingAssistant = None
    ) -&gt; FeedbackTO | tuple[FeedbackTO, ModelingAssistant]:
    &#34;Give feedback given a student class diagram.&#34;
    # pylint: disable=protected-access
    use_local_ma = bool(ma)
    ma = ma or MODELING_ASSISTANT.instance

    if isinstance(student_cdm, str):
        student_cdm = str_to_cdm(student_cdm)

    instructor_cdm = instructor_solution_for(student_cdm, ma).classDiagram
    student_solution = student_solution_for(username, student_cdm, ma)  # useful line to create solution, do not remove

    cdms2sols = ma.classDiagramsToSolutions
    ma = get_mistakes(ma, instructor_cdm, student_cdm)
    if not ma.classDiagramsToSolutions:
        ma.classDiagramsToSolutions = cdms2sols
    if not use_local_ma:
        MODELING_ASSISTANT.instance = ma
    student_solution = student_solution_for(username, student_cdm, ma)
    fb_s = give_feedback(student_solution)
    fb = fb_s if isinstance(fb_s, FeedbackItem) else fb_s[0]  # only one feedback item for now

    if not fb.mistake:
        return FeedbackTO()
    feedback = FeedbackTO(feedback=fb)
    return (feedback, ma) if use_local_ma else feedback


@cache
def instructor_solution_for(student_cdm: ClassDiagram, ma: ModelingAssistant = None) -&gt; Solution:
    &#34;Return the instructor solution for the given student class diagram.&#34;
    # TODO Assume only one problem statement for now
    ma = ma or MODELING_ASSISTANT.instance
    return next(sol for sol in ma.solutions if not sol.student)


def student_solution_for(username: str, student_cdm: ClassDiagram, ma: ModelingAssistant) -&gt; Solution:
    &#34;Return the student solution for the given student class diagram.&#34;
    # pylint: disable=protected-access
    student = next((s for s in ma.students if s.name == username), None) or Student(name=username, modelingAssistant=ma)
    ps: ProblemStatement = ma.problemStatements[0]  # TODO Assume only one problem statement for now
    stud_sol = (next((sol for sol in ma.solutions if sol.student and sol.student.name == username
                      and sol.classDiagram._internal_id == student_cdm._internal_id), None)
                or Solution(student=student, classDiagram=student_cdm, modelingAssistant=ma, problemStatement=ps))
    stud_sol.classDiagram = student_cdm
    old_sol = None
    for sol in ps.studentSolutions:
        if sol.student.name == username and sol.classDiagram._internal_id == student_cdm._internal_id:
            old_sol = sol
            break
    if old_sol:
        ps.studentSolutions.remove(old_sol)
    ps.studentSolutions.append(stud_sol)
    return stud_sol


def verbalize_feedback_description(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    Verbalize the feedback description of the given feedback item.

    When debug mode is on, return a description string for highlighted problem statement and solution elements, to
    make it easier to work on the frontend.

    For all text feedback, perform the following changes:

    - If the student is a beginner, include the text [within square brackets] in the feedback, without the square
      brackets themselves. Otherwise, omit this text entirely
    - If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
      (An|an). In the future, use a NLP package to correctly handle cases like &#34;a university&#34;.

    For resource responses, indicate the resource type and the contents if no dedicated transformation is available.
    &#34;&#34;&#34;
    if not feedback:
        warn(&#34;verbalize_feedback_description(): input feedback is None&#34;)
        return &#34;&#34;
    highlight_info = verbalize_highlight_description(feedback)
    resource_info = verbalize_resource_description(feedback)
    written_feedback = verbalize_written_feedback(feedback)
    sep = &#34;\n\n&#34; if highlight_info else &#34;&#34;
    result = f&#34;{written_feedback}{resource_info}{sep}{highlight_info}&#34;
    result = process_optional_text(result, is_beginner=True)  # TODO handle intermediate and advanced students later
    result = process_indefinite_articles(result)
    return result


def verbalize_highlight_description(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    When debug mode is on, return a description string for highlighted problem statement and solution elements, to
    make it easier to work on the frontend.
    &#34;&#34;&#34;
    if not modelingassistantapp.DEBUG_MODE:  # need to specify name to capture changes to DEBUG_MODE when testing
        return &#34;&#34;
    fb_item, fb_template = feedback, feedback.feedback
    mistake: Mistake = fb_item.mistake
    color = fb_template.text if (fb_template.text or &#34;&#34;).startswith(&#34;#&#34;) else str(DEFAULT_HIGHLIGHT_COLOR)
    prefix = &#34;Highlight &#34;
    result = &#34;&#34;
    if fb_template.highlightProblem:
        fragments = list(filter(bool, [&#34; &#34;.join(map(lambda e: e.name, ie.problemStatementElements))
                                       for ie in mistake.instructorElements]))
        suffix = f&#34; in the problem statement in {color}&#34;
        if (n := len(fragments)) == 0:
            warn(&#34;verbalize_highlight_description(): no problem statement elements found for Feedback with &#34;
                 &#34;highlightProblem=True&#34;)
        elif n == 1:
            result = f&#39;{prefix}&#34;{fragments[0]}&#34;{suffix}&#39;
        elif n == 2:
            result = f&#39;{prefix}&#34;{fragments[0]}&#34; and &#34;{fragments[1]}&#34;{suffix}&#39;
        else:
            result = f&#39;{prefix}{&#34;, &#34;.join(quote(f) for f in fragments[:-1])}, and {fragments[-1]}{suffix}&#39;
    if fb_template.highlightSolution:
        stud_elems = [e.element for e in mistake.studentElements]
        sep = &#34;\n\n&#34; if result else &#34;&#34;
        result = f&#34;{result}{sep}{prefix}{comma_seperated_with_and(stud_elems)} in the solution in {color}&#34;
    return result


def verbalize_written_feedback(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    If the feedback has a text or parametrized response, process and return it. Otherwise, return an empty string.
    &#34;&#34;&#34;
    fb_item, fb_template = feedback, feedback.feedback
    mistake: Mistake = fb_item.mistake
    result = &#34;&#34;
    if isinstance(fb_template, TextResponse | ParametrizedResponse):
        result = fb_item.text or fb_template.text
    # special cases for certain mistake types, make this more general if corpus grows
    if mistake.mistakeType.name in [infinite_recursive_dependency.name, missing_multiplicity.name]:
        if len(mistake.studentElements) &gt; 1:  # multiple wrong multiplicities
            result = result.replace(&#34;(y|ies)&#34;, &#34;ies&#34;).replace(&#34;(is|are)&#34;, &#34;are&#34;)
        else:
            result = result.replace(&#34;(y|ies)&#34;, &#34;y&#34;).replace(&#34;(is|are)&#34;, &#34;is&#34;)
    return result


def verbalize_resource_description(feedback: FeedbackItem | Feedback) -&gt; str:
    &#34;&#34;&#34;
    If the feedback is or has a resource response, return a description of the resource. Otherwise, return an empty
    string.
    &#34;&#34;&#34;
    feedback: Feedback = feedback.feedback if isinstance(feedback, FeedbackItem) else feedback
    if isinstance(feedback, ResourceResponse):
        return &#34;\n&#34;.join(f&#34;{type(r).__name__}: {r.content}&#34; for r in feedback.learningResources)
    return &#34;&#34;


def process_optional_text(text: str, is_beginner: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Return the given text, but if is_beginner is True (the default), include text [within square brackets] without the
    square brackets themselves. Otherwise, omit the text within entirely. In either case, preserve Markdown links and
    images.
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    if text.startswith(&#34;[&#34;):
        text = f&#34; {text}&#34;
    text_chunks = text.split(&#34;[&#34;)
    result = &#34;&#34;
    for chunk in text_chunks:
        if &#34;](&#34; in chunk:
            result += f&#34;[{chunk}&#34;  # preserve markdown links and images
        elif &#34;]&#34; in chunk:
            if is_beginner:
                result += chunk.replace(&#34;]&#34;, &#34;&#34;)  # include chunk without the closing bracket
            else:
                result += chunk.split(&#34;]&#34;, 1)[1]
        else:
            result += chunk
    return result.strip()


def process_indefinite_articles(text: str) -&gt; str:
    &#34;&#34;&#34;
    If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
    (An|an). In the future, use a NLP package to correctly handle cases like &#34;a university&#34;.
    &#34;&#34;&#34;
    for v in &#34;aeiouAEIOU&#34;:
        text = text.replace(f&#34; a {v}&#34;, f&#34; an {v}&#34;).replace(f&#34;A {v}&#34;, f&#34;An {v}&#34;)
    return text


if __name__ == &#39;__main__&#39;:
    &#34;Main entry point (used for debugging).&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="feedback.give_feedback"><code class="name flex">
<span>def <span class="ident">give_feedback</span></span>(<span>student_solution: <a title="modelingassistant.modelingassistant.Solution" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Solution">Solution</a>) ‑> <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a> | list[<a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Give feedback on the given student solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_feedback(student_solution: Solution) -&gt; FeedbackItem | list[FeedbackItem]:
    &#34;Give feedback on the given student solution.&#34;
    if student_solution is not student_solution.student.currentSolution:
        pass  # return None  # do not give feedback for other unrelated solutions
    if not student_solution.mistakes:
        # emoji to test serdes
        return FeedbackItem(feedback=TextResponse(text=&#34;All good, no mistakes found! 🎉&#34;), solution=student_solution)

    # sort mistakes by priority and filter out mistakes which are already resolved
    unresolved_mistakes: list[Mistake] = [
        m for m in sorted(student_solution.mistakes, key=lambda m: m.mistakeType.priority) if not m.resolvedByStudent]

    # update student knowledge for each unresolved mistake type
    for m in unresolved_mistakes:
        student_knowledge_for(m).levelOfKnowledge = MAX_STUDENT_LEVEL_OF_KNOWLEDGE - m.numDetections

    # sort highest priority mistakes based on number of detections (start with those detected the most times)
    highest_priority = unresolved_mistakes[0].mistakeType.priority
    highest_priority_mistakes = sorted([m for m in unresolved_mistakes if m.mistakeType.priority == highest_priority],
                                       key=lambda m: m.numDetections, reverse=True)

    result: list[FeedbackItem] = []

    for m in highest_priority_mistakes:
        #student_solution.currentMistake = m  # TODO
        result.append(next_feedback(m))
        # decide whether student is beginner overall
        if student_knowledge_for(m).levelOfKnowledge &lt; BEGINNER_LEVEL_OF_KNOWLEDGE:
            break

    resolved_mistakes: list[Mistake] = [m for m in student_solution.mistakes if m.resolvedByStudent]
    for m in resolved_mistakes:
        if sk := student_knowledge_for(m):
            if m.lastFeedback: # ignore mistakes which have been resolved before feedback was given on them
                sk.levelOfKnowledge += m.lastFeedback.feedback.level / 2

    return result[0] if len(result) == 1 else result</code></pre>
</details>
</dd>
<dt id="feedback.give_feedback_for_student_cdm"><code class="name flex">
<span>def <span class="ident">give_feedback_for_student_cdm</span></span>(<span>username: str, student_cdm: <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a> | str, ma: <a title="modelingassistant.modelingassistant.ModelingAssistant" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.ModelingAssistant">ModelingAssistant</a> = None) ‑> <a title="feedback.FeedbackTO" href="#feedback.FeedbackTO">FeedbackTO</a> | tuple[<a title="feedback.FeedbackTO" href="#feedback.FeedbackTO">FeedbackTO</a>, <a title="modelingassistant.modelingassistant.ModelingAssistant" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.ModelingAssistant">ModelingAssistant</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Give feedback given a student class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_feedback_for_student_cdm(username: str, student_cdm: ClassDiagram | str, ma: ModelingAssistant = None
    ) -&gt; FeedbackTO | tuple[FeedbackTO, ModelingAssistant]:
    &#34;Give feedback given a student class diagram.&#34;
    # pylint: disable=protected-access
    use_local_ma = bool(ma)
    ma = ma or MODELING_ASSISTANT.instance

    if isinstance(student_cdm, str):
        student_cdm = str_to_cdm(student_cdm)

    instructor_cdm = instructor_solution_for(student_cdm, ma).classDiagram
    student_solution = student_solution_for(username, student_cdm, ma)  # useful line to create solution, do not remove

    cdms2sols = ma.classDiagramsToSolutions
    ma = get_mistakes(ma, instructor_cdm, student_cdm)
    if not ma.classDiagramsToSolutions:
        ma.classDiagramsToSolutions = cdms2sols
    if not use_local_ma:
        MODELING_ASSISTANT.instance = ma
    student_solution = student_solution_for(username, student_cdm, ma)
    fb_s = give_feedback(student_solution)
    fb = fb_s if isinstance(fb_s, FeedbackItem) else fb_s[0]  # only one feedback item for now

    if not fb.mistake:
        return FeedbackTO()
    feedback = FeedbackTO(feedback=fb)
    return (feedback, ma) if use_local_ma else feedback</code></pre>
</details>
</dd>
<dt id="feedback.instructor_solution_for"><code class="name flex">
<span>def <span class="ident">instructor_solution_for</span></span>(<span>student_cdm: <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, ma: <a title="modelingassistant.modelingassistant.ModelingAssistant" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.ModelingAssistant">ModelingAssistant</a> = None) ‑> <a title="modelingassistant.modelingassistant.Solution" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Solution">Solution</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the instructor solution for the given student class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cache
def instructor_solution_for(student_cdm: ClassDiagram, ma: ModelingAssistant = None) -&gt; Solution:
    &#34;Return the instructor solution for the given student class diagram.&#34;
    # TODO Assume only one problem statement for now
    ma = ma or MODELING_ASSISTANT.instance
    return next(sol for sol in ma.solutions if not sol.student)</code></pre>
</details>
</dd>
<dt id="feedback.next_feedback"><code class="name flex">
<span>def <span class="ident">next_feedback</span></span>(<span>mistake: <a title="modelingassistant.modelingassistant.Mistake" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Mistake">Mistake</a>) ‑> <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the feedback item at the next level for the given mistake, eg,</p>
<pre><code>next_feedback(mistake with lastFeedback.level = 2) = feedback at level 3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_feedback(mistake: Mistake) -&gt; FeedbackItem:
    &#34;&#34;&#34;
    Return the feedback item at the next level for the given mistake, eg,

        next_feedback(mistake with lastFeedback.level = 2) = feedback at level 3
    &#34;&#34;&#34;
    target_level = mistake.lastFeedback.feedback.level + 1 if mistake.lastFeedback else 1
    next_fb: Feedback = set_static_class_for(
        next(fb for fb in mistake.mistakeType.feedbacks if fb.level == target_level))
    fb_text = next_fb.text
    if isinstance(next_fb, ParametrizedResponse):
        fb_text = parametrize_response(next_fb, mistake)
    return FeedbackItem(text=fb_text, feedback=next_fb, solution=mistake.solution, mistake=mistake)</code></pre>
</details>
</dd>
<dt id="feedback.process_indefinite_articles"><code class="name flex">
<span>def <span class="ident">process_indefinite_articles</span></span>(<span>text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
(An|an). In the future, use a NLP package to correctly handle cases like "a university".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_indefinite_articles(text: str) -&gt; str:
    &#34;&#34;&#34;
    If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
    (An|an). In the future, use a NLP package to correctly handle cases like &#34;a university&#34;.
    &#34;&#34;&#34;
    for v in &#34;aeiouAEIOU&#34;:
        text = text.replace(f&#34; a {v}&#34;, f&#34; an {v}&#34;).replace(f&#34;A {v}&#34;, f&#34;An {v}&#34;)
    return text</code></pre>
</details>
</dd>
<dt id="feedback.process_optional_text"><code class="name flex">
<span>def <span class="ident">process_optional_text</span></span>(<span>text: str, is_beginner: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the given text, but if is_beginner is True (the default), include text [within square brackets] without the
square brackets themselves. Otherwise, omit the text within entirely. In either case, preserve Markdown links and
images.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_optional_text(text: str, is_beginner: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Return the given text, but if is_beginner is True (the default), include text [within square brackets] without the
    square brackets themselves. Otherwise, omit the text within entirely. In either case, preserve Markdown links and
    images.
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    if text.startswith(&#34;[&#34;):
        text = f&#34; {text}&#34;
    text_chunks = text.split(&#34;[&#34;)
    result = &#34;&#34;
    for chunk in text_chunks:
        if &#34;](&#34; in chunk:
            result += f&#34;[{chunk}&#34;  # preserve markdown links and images
        elif &#34;]&#34; in chunk:
            if is_beginner:
                result += chunk.replace(&#34;]&#34;, &#34;&#34;)  # include chunk without the closing bracket
            else:
                result += chunk.split(&#34;]&#34;, 1)[1]
        else:
            result += chunk
    return result.strip()</code></pre>
</details>
</dd>
<dt id="feedback.student_knowledge_for"><code class="name flex">
<span>def <span class="ident">student_knowledge_for</span></span>(<span>mistake: <a title="modelingassistant.modelingassistant.Mistake" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Mistake">Mistake</a>) ‑> <a title="modelingassistant.modelingassistant.StudentKnowledge" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.StudentKnowledge">StudentKnowledge</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the student knowledge object for the given mistake (a mistake is made by a specific student).
If not found, create a new one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def student_knowledge_for(mistake: Mistake) -&gt; StudentKnowledge:
    &#34;&#34;&#34;
    Return the student knowledge object for the given mistake (a mistake is made by a specific student).
    If not found, create a new one.
    &#34;&#34;&#34;
    # pylint: disable=protected-access
    # TODO Cache studentknowledges or redesign metamodel to access them in O(1) time instead of O(n)
    student = mistake.solution.student
    # print statements for debugging, will be cleaned up later
    #print(&#34;Student knowledges for&#34;, student.name, &#34;Mistake&#34;, mistake.mistakeType.name,mistake.mistakeType._internal_id)
    for sk in student.studentKnowledges:
        #print(&#34;&gt;&gt;&gt;&#34;, sk.mistakeType.name, sk.mistakeType._internal_id, sk.levelOfKnowledge)
        if sk.mistakeType._internal_id == mistake.mistakeType._internal_id:
            #print(&#34;--- Returning existing SK\n&#34;)
            return sk
    #print(f&#34;** Creating new SK for mistake type {mistake.mistakeType.name} ({mistake.mistakeType._internal_id}) **\n&#34;)
    return StudentKnowledge(student=student, mistakeType=mistake.mistakeType, levelOfKnowledge=5.0,
                            modelingAssistant=mistake.solution.modelingAssistant)</code></pre>
</details>
</dd>
<dt id="feedback.student_solution_for"><code class="name flex">
<span>def <span class="ident">student_solution_for</span></span>(<span>username: str, student_cdm: <a title="classdiagram.classdiagram.ClassDiagram" href="classdiagram/classdiagram.html#classdiagram.classdiagram.ClassDiagram">ClassDiagram</a>, ma: <a title="modelingassistant.modelingassistant.ModelingAssistant" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.ModelingAssistant">ModelingAssistant</a>) ‑> <a title="modelingassistant.modelingassistant.Solution" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Solution">Solution</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the student solution for the given student class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def student_solution_for(username: str, student_cdm: ClassDiagram, ma: ModelingAssistant) -&gt; Solution:
    &#34;Return the student solution for the given student class diagram.&#34;
    # pylint: disable=protected-access
    student = next((s for s in ma.students if s.name == username), None) or Student(name=username, modelingAssistant=ma)
    ps: ProblemStatement = ma.problemStatements[0]  # TODO Assume only one problem statement for now
    stud_sol = (next((sol for sol in ma.solutions if sol.student and sol.student.name == username
                      and sol.classDiagram._internal_id == student_cdm._internal_id), None)
                or Solution(student=student, classDiagram=student_cdm, modelingAssistant=ma, problemStatement=ps))
    stud_sol.classDiagram = student_cdm
    old_sol = None
    for sol in ps.studentSolutions:
        if sol.student.name == username and sol.classDiagram._internal_id == student_cdm._internal_id:
            old_sol = sol
            break
    if old_sol:
        ps.studentSolutions.remove(old_sol)
    ps.studentSolutions.append(stud_sol)
    return stud_sol</code></pre>
</details>
</dd>
<dt id="feedback.verbalize_feedback_description"><code class="name flex">
<span>def <span class="ident">verbalize_feedback_description</span></span>(<span>feedback: <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Verbalize the feedback description of the given feedback item.</p>
<p>When debug mode is on, return a description string for highlighted problem statement and solution elements, to
make it easier to work on the frontend.</p>
<p>For all text feedback, perform the following changes:</p>
<ul>
<li>If the student is a beginner, include the text [within square brackets] in the feedback, without the square
brackets themselves. Otherwise, omit this text entirely</li>
<li>If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
(An|an). In the future, use a NLP package to correctly handle cases like "a university".</li>
</ul>
<p>For resource responses, indicate the resource type and the contents if no dedicated transformation is available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verbalize_feedback_description(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    Verbalize the feedback description of the given feedback item.

    When debug mode is on, return a description string for highlighted problem statement and solution elements, to
    make it easier to work on the frontend.

    For all text feedback, perform the following changes:

    - If the student is a beginner, include the text [within square brackets] in the feedback, without the square
      brackets themselves. Otherwise, omit this text entirely
    - If an indefinite article (A|a) is found in the text and the following word starts with a vowel, replace with
      (An|an). In the future, use a NLP package to correctly handle cases like &#34;a university&#34;.

    For resource responses, indicate the resource type and the contents if no dedicated transformation is available.
    &#34;&#34;&#34;
    if not feedback:
        warn(&#34;verbalize_feedback_description(): input feedback is None&#34;)
        return &#34;&#34;
    highlight_info = verbalize_highlight_description(feedback)
    resource_info = verbalize_resource_description(feedback)
    written_feedback = verbalize_written_feedback(feedback)
    sep = &#34;\n\n&#34; if highlight_info else &#34;&#34;
    result = f&#34;{written_feedback}{resource_info}{sep}{highlight_info}&#34;
    result = process_optional_text(result, is_beginner=True)  # TODO handle intermediate and advanced students later
    result = process_indefinite_articles(result)
    return result</code></pre>
</details>
</dd>
<dt id="feedback.verbalize_highlight_description"><code class="name flex">
<span>def <span class="ident">verbalize_highlight_description</span></span>(<span>feedback: <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>When debug mode is on, return a description string for highlighted problem statement and solution elements, to
make it easier to work on the frontend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verbalize_highlight_description(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    When debug mode is on, return a description string for highlighted problem statement and solution elements, to
    make it easier to work on the frontend.
    &#34;&#34;&#34;
    if not modelingassistantapp.DEBUG_MODE:  # need to specify name to capture changes to DEBUG_MODE when testing
        return &#34;&#34;
    fb_item, fb_template = feedback, feedback.feedback
    mistake: Mistake = fb_item.mistake
    color = fb_template.text if (fb_template.text or &#34;&#34;).startswith(&#34;#&#34;) else str(DEFAULT_HIGHLIGHT_COLOR)
    prefix = &#34;Highlight &#34;
    result = &#34;&#34;
    if fb_template.highlightProblem:
        fragments = list(filter(bool, [&#34; &#34;.join(map(lambda e: e.name, ie.problemStatementElements))
                                       for ie in mistake.instructorElements]))
        suffix = f&#34; in the problem statement in {color}&#34;
        if (n := len(fragments)) == 0:
            warn(&#34;verbalize_highlight_description(): no problem statement elements found for Feedback with &#34;
                 &#34;highlightProblem=True&#34;)
        elif n == 1:
            result = f&#39;{prefix}&#34;{fragments[0]}&#34;{suffix}&#39;
        elif n == 2:
            result = f&#39;{prefix}&#34;{fragments[0]}&#34; and &#34;{fragments[1]}&#34;{suffix}&#39;
        else:
            result = f&#39;{prefix}{&#34;, &#34;.join(quote(f) for f in fragments[:-1])}, and {fragments[-1]}{suffix}&#39;
    if fb_template.highlightSolution:
        stud_elems = [e.element for e in mistake.studentElements]
        sep = &#34;\n\n&#34; if result else &#34;&#34;
        result = f&#34;{result}{sep}{prefix}{comma_seperated_with_and(stud_elems)} in the solution in {color}&#34;
    return result</code></pre>
</details>
</dd>
<dt id="feedback.verbalize_resource_description"><code class="name flex">
<span>def <span class="ident">verbalize_resource_description</span></span>(<span>feedback: <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a> | <a title="learningcorpus.learningcorpus.Feedback" href="learningcorpus/learningcorpus.html#learningcorpus.learningcorpus.Feedback">Feedback</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>If the feedback is or has a resource response, return a description of the resource. Otherwise, return an empty
string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verbalize_resource_description(feedback: FeedbackItem | Feedback) -&gt; str:
    &#34;&#34;&#34;
    If the feedback is or has a resource response, return a description of the resource. Otherwise, return an empty
    string.
    &#34;&#34;&#34;
    feedback: Feedback = feedback.feedback if isinstance(feedback, FeedbackItem) else feedback
    if isinstance(feedback, ResourceResponse):
        return &#34;\n&#34;.join(f&#34;{type(r).__name__}: {r.content}&#34; for r in feedback.learningResources)
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="feedback.verbalize_written_feedback"><code class="name flex">
<span>def <span class="ident">verbalize_written_feedback</span></span>(<span>feedback: <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>If the feedback has a text or parametrized response, process and return it. Otherwise, return an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verbalize_written_feedback(feedback: FeedbackItem) -&gt; str:
    &#34;&#34;&#34;
    If the feedback has a text or parametrized response, process and return it. Otherwise, return an empty string.
    &#34;&#34;&#34;
    fb_item, fb_template = feedback, feedback.feedback
    mistake: Mistake = fb_item.mistake
    result = &#34;&#34;
    if isinstance(fb_template, TextResponse | ParametrizedResponse):
        result = fb_item.text or fb_template.text
    # special cases for certain mistake types, make this more general if corpus grows
    if mistake.mistakeType.name in [infinite_recursive_dependency.name, missing_multiplicity.name]:
        if len(mistake.studentElements) &gt; 1:  # multiple wrong multiplicities
            result = result.replace(&#34;(y|ies)&#34;, &#34;ies&#34;).replace(&#34;(is|are)&#34;, &#34;are&#34;)
        else:
            result = result.replace(&#34;(y|ies)&#34;, &#34;y&#34;).replace(&#34;(is|are)&#34;, &#34;is&#34;)
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="feedback.FeedbackTO"><code class="flex name class">
<span>class <span class="ident">FeedbackTO</span></span>
<span>(</span><span>solutionElements: dict[str, list[str]] = Field(name=None,type=None,default=&lt;dataclasses._MISSING_TYPE object&gt;,default_factory=&lt;class &#x27;dict&#x27;&gt;,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=&lt;dataclasses._MISSING_TYPE object&gt;,_field_type=None), problemStatementElements: dict[str, list[str]] = Field(name=None,type=None,default=&lt;dataclasses._MISSING_TYPE object&gt;,default_factory=&lt;class &#x27;dict&#x27;&gt;,init=True,repr=True,hash=None,compare=True,metadata=mappingproxy({}),kw_only=&lt;dataclasses._MISSING_TYPE object&gt;,_field_type=None), grade: float = 0.0, writtenFeedback: str = '', feedback: <a title="modelingassistant.modelingassistant.FeedbackItem" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.FeedbackItem">FeedbackItem</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Feedback transfer object class. An explicit class is used to allow for lint and compile-time type checking.</p>
<p>When transformed to JSON, this object will have the following structure:</p>
<pre><code class="language-json">{
    &quot;grade&quot;: 0.0,
    &quot;problemStatementElements&quot;: {&quot;#fffacd&quot;: [&quot;7&quot;, &quot;8&quot;, &quot;9&quot;]},
    &quot;solutionElements&quot;: {&quot;#add8e6&quot;: [ &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]},
    &quot;writtenFeedback&quot;: &quot;The hex strings above refer to the colors used to highlight the diagram elements.&quot;
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class FeedbackTO:
    &#34;&#34;&#34;
    Feedback transfer object class. An explicit class is used to allow for lint and compile-time type checking.

    When transformed to JSON, this object will have the following structure:

    ```json
    {
        &#34;grade&#34;: 0.0,
        &#34;problemStatementElements&#34;: {&#34;#fffacd&#34;: [&#34;7&#34;, &#34;8&#34;, &#34;9&#34;]},
        &#34;solutionElements&#34;: {&#34;#add8e6&#34;: [ &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;]},
        &#34;writtenFeedback&#34;: &#34;The hex strings above refer to the colors used to highlight the diagram elements.&#34;
    }
    ```
    &#34;&#34;&#34;
    # pylint: disable=invalid-name, protected-access
    solutionElements: dict[str, list[str]] = field(default_factory=dict)  # includes generalizations
    problemStatementElements: dict[str, list[str]] = field(default_factory=dict)
    grade: float = 0.0
    writtenFeedback: str = &#34;&#34;

    # custom __init__ for correct JSON (de)serialization
    def __init__(self, solutionElements: dict[str, list[str]] = field(default_factory=dict),
                 problemStatementElements: dict[str, list[str]] = field(default_factory=dict),
                 grade: float = 0.0, writtenFeedback: str = &#34;&#34;, feedback: FeedbackItem = None):
        # pylint: disable=too-many-arguments
        def make_highlighted_elems(
            elems: Iterable[str] | Iterable[NamedElement] | Iterable[SolutionElement]
                 | dict[str, list[str] | list[NamedElement] | list[SolutionElement]]) -&gt; dict[str, list[str]]:
            def id_for(e: str | NamedElement | SolutionElement) -&gt; str:
                if not isinstance(e, str | NamedElement | SolutionElement):
                    raise TypeError(f&#34;Expected str, NamedElement, or SolutionElement but got {e} of type {type(e)}&#34;)
                return e.element._internal_id if isinstance(e, SolutionElement) else (
                    e._internal_id if isinstance(e, NamedElement) else e)
            if not elems:
                return {}
            if isinstance(elems, list | OrderedSet):
                return {DEFAULT_HIGHLIGHT_COLOR.to_hex(): [id_for(e) for e in elems]}
            if isinstance(elems, dict):
                return {color: [id_for(e) for e in elems[color]] for color in elems}
            raise TypeError(f&#34;Unexpected type elems type: {type(elems)}&#34;)

        def get_ids(elems: dict[str, list[str]]) -&gt; list[str]:
            result = set()
            for ids in elems.values():
                result.update(ids)
            return list(result)

        if feedback:
            solutionElements: OrderedSet[SolutionElement] = feedback.mistake.studentElements
            problemStatementElements: OrderedSet[SolutionElement] = feedback.mistake.instructorElements
            writtenFeedback = verbalize_feedback_description(feedback)
        self.solutionElements = make_highlighted_elems(solutionElements)
        self.solutionElementIds = get_ids(self.solutionElements)
        self.problemStatementElements = make_highlighted_elems(problemStatementElements)
        self.problemStatementElementIds = get_ids(self.problemStatementElements)
        self.grade = grade
        self.writtenFeedback = writtenFeedback</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="feedback.FeedbackTO.grade"><code class="name">var <span class="ident">grade</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="feedback.FeedbackTO.problemStatementElements"><code class="name">var <span class="ident">problemStatementElements</span> : dict[str, list[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="feedback.FeedbackTO.solutionElements"><code class="name">var <span class="ident">solutionElements</span> : dict[str, list[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="feedback.FeedbackTO.writtenFeedback"><code class="name">var <span class="ident">writtenFeedback</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="feedback.give_feedback" href="#feedback.give_feedback">give_feedback</a></code></li>
<li><code><a title="feedback.give_feedback_for_student_cdm" href="#feedback.give_feedback_for_student_cdm">give_feedback_for_student_cdm</a></code></li>
<li><code><a title="feedback.instructor_solution_for" href="#feedback.instructor_solution_for">instructor_solution_for</a></code></li>
<li><code><a title="feedback.next_feedback" href="#feedback.next_feedback">next_feedback</a></code></li>
<li><code><a title="feedback.process_indefinite_articles" href="#feedback.process_indefinite_articles">process_indefinite_articles</a></code></li>
<li><code><a title="feedback.process_optional_text" href="#feedback.process_optional_text">process_optional_text</a></code></li>
<li><code><a title="feedback.student_knowledge_for" href="#feedback.student_knowledge_for">student_knowledge_for</a></code></li>
<li><code><a title="feedback.student_solution_for" href="#feedback.student_solution_for">student_solution_for</a></code></li>
<li><code><a title="feedback.verbalize_feedback_description" href="#feedback.verbalize_feedback_description">verbalize_feedback_description</a></code></li>
<li><code><a title="feedback.verbalize_highlight_description" href="#feedback.verbalize_highlight_description">verbalize_highlight_description</a></code></li>
<li><code><a title="feedback.verbalize_resource_description" href="#feedback.verbalize_resource_description">verbalize_resource_description</a></code></li>
<li><code><a title="feedback.verbalize_written_feedback" href="#feedback.verbalize_written_feedback">verbalize_written_feedback</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="feedback.FeedbackTO" href="#feedback.FeedbackTO">FeedbackTO</a></code></h4>
<ul class="">
<li><code><a title="feedback.FeedbackTO.grade" href="#feedback.FeedbackTO.grade">grade</a></code></li>
<li><code><a title="feedback.FeedbackTO.problemStatementElements" href="#feedback.FeedbackTO.problemStatementElements">problemStatementElements</a></code></li>
<li><code><a title="feedback.FeedbackTO.solutionElements" href="#feedback.FeedbackTO.solutionElements">solutionElements</a></code></li>
<li><code><a title="feedback.FeedbackTO.writtenFeedback" href="#feedback.FeedbackTO.writtenFeedback">writtenFeedback</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>