<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>parametrizedresponse API documentation</title>
<meta name="description" content="Logic to handle parametrized responses." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parametrizedresponse</code></h1>
</header>
<section id="section-intro">
<p>Logic to handle parametrized responses.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Logic to handle parametrized responses.
&#34;&#34;&#34;

import re
from collections.abc import Iterable
from string import Formatter

from ordered_set import OrderedSet
from pyecore.ecore import EClass

from metatypes import Metatype, CDM_METATYPES as metatypes
from utils import warn
from classdiagram import Association, AssociationEnd, Attribute, CDEnumLiteral, Classifier, NamedElement
from learningcorpus import MistakeElement, MistakeType, ParametrizedResponse
from modelingassistant import Mistake


MAX_VARARG_SEQUENCE_LENGTH = float(&#34;inf&#34;)  # The maximum number of vararg elements for a parameter

_MAX_PARSE_DEPTH = 15  # Maximum depth of parse tree, eg, A.B.C... cannot have more (\.\*\d) than this

_MAX_INDEX = 15  # Maximum value of a sequence index, eg, inst_assocend1

# CDM metamodel shorthands
SHORTHANDS: dict[str, str] = {
    &#34;cls&#34;: &#34;classifier&#34;,
    &#34;cls*&#34;: &#34;ends&#34;,  # fallback
    &#34;end&#34;: &#34;ends&#34;,
    &#34;refcls&#34;: &#34;oppositeEnd&#34;,  # fallback
    &#34;opposite&#34;: &#34;oppositeEnd&#34;,
}

_formatter = Formatter()


def parametrize_response(response: ParametrizedResponse, mistake: Mistake) -&gt; str:
    &#34;&#34;&#34;
    Return the filled-in parametrized response text for the given response and mistake.

    This function uses the following approach to determing the returned text:

    1. Map mistake type element descriptions to mistake elements
    2. Extract parameter template strings from parametrized response text, eg, ${stud_attr.cls}
    3. Get parameter part before dot, eg, stud_attr. This is the start element, passed into the parse() function
    4. Populate the options dictionary with (original parameter, replacement) pairs
    5. Use the Python string formatter to replace the parameter template strings with the corresponding values

    Example execution (Python-like pseudocode):

    ```
    Given MistakeType WRONG_CLASS_NAME with student element cls and instructor element cls:
    parametrize_response(resp=&#34;${stud_cls} should be ${inst_cls}.&#34;, mistake={mt: WRONG_CLASS_NAME, se: [sc], ie: [ic]}):
        1. Establish mapping {stud_cls: sc, inst_cls: ic}
        2. Extract parameters: stud_cls, inst_cls
        3. Get part before dot: stud_cls, inst_cls (no change for this example)
        4. Populate options by calling parse() for each one: {stud_cls: sc, inst_cls: ic}
        5. Return resulting string with replacements: &#34;sc should be ic.&#34;
    ```

    For other more interesting examples, see the unit tests.
    &#34;&#34;&#34;
    options: dict[str, str] = {}
    mt_elem_descriptions_to_mistake_elems = get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems(mistake)
    params = extract_params(response.text)
    param_roots = param_parts_before_dot(params)
    for param, param_root in zip(params, param_roots):
        start_elem = mt_elem_descriptions_to_mistake_elems.get(param_root)
        if start_elem is None:
            warn(f&#34;parametrizedresponse.parametrize_response(): Parameter {param} not found for mistake {mistake}&#34;)
            continue
        options[param] = parse(param, start_elem)
    # print(f&#34;parametrizedresponse.parametrize_response(): {options = }&#34;)  # TODO remove later
    resp_text: str = response.text.replace(&#34;$&#34;, &#34;&#34;)  # remove all $ from the response text
    for t in _formatter.parse(resp_text):  # not to be confused with the parse() function defined below
        # print(f&#34;parametrizedresponse.parametrize_response(): {t = }&#34;)  # TODO remove later
        if t[1] is not None:
            resp_text = resp_text.replace(f&#34;{{{t[1]}}}&#34;, options[t[1]], 1)
    return resp_text


def parse(s: str, start_elem: NamedElement) -&gt; str:
    &#34;&#34;&#34;
    Recursively parse a parameter from a parametrized response string, as applied on the input starting element.
    The format of the parameter is as follows:

    ```
    (&#39;stud&#39;|&#39;inst&#39;)_[description_]elementtype[(&#39;*&#39;|index)][.elementproperty[(&#39;*&#39;|index)]]*
    ```

    - elementtype is a CDM metatype.
    - description is a string that provides more information about the parameter, eg, inst_super_cls.
    It is needed whenever there is more than one parameter with the same person (stud/inst) and the same type
    - index is an integer, used to get the nth element of a sequence where applicable, eg, inst_assocend0
    - elementproperty is a property (field) defined on an element at the metamodel level
    or a predefined shorthand for it like &#39;cls&#39;
    &#34;&#34;&#34;
    if not param_valid(s):
        raise ValueError(f&#34;Invalid parametrized response parameter: {s}&#34;)
    return _parse(s, start_elem)  # call internal helper function to do actual parsing


def _parse(s: str, start_elem: NamedElement | Iterable, depth: int = 0) -&gt; str:
    # pylint: disable=too-many-return-statements
    # print(f&#34;parametrizedresponse.parse({s = }, {start_elem = }) called&#34;)  # TODO remove later
    if depth &gt; _MAX_PARSE_DEPTH:
        raise ValueError(f&#34;parametrizedresponse.parse(): reached max parse depth ({_MAX_PARSE_DEPTH})&#34;)

    # base cases
    if re.match(r&#34;^[A-Za-z_]+$&#34;, s):  # simplest case, only a metatype
        if isinstance(start_elem, Association):  # do not rely on TouchCORE assoc naming since it is an internal detail
            return &#34;_&#34;.join((ae.classifier.name for ae in start_elem.ends))
        return getattr(start_elem, &#34;name&#34;, str(start_elem))
    if re.match(r&#34;^[A-Za-z_]+\*$&#34;, s):  # simple varargs list of metatypes
        # special case for n-ary associations
        if isinstance(start_elem, Iterable) and all(isinstance(e, AssociationEnd) for e in start_elem) and s == &#34;cls*&#34;:
            return comma_seperated_with_and([ae.classifier for ae in start_elem])
        # special case for Player-Role pattern roles
        if s.endswith(&#34;role*&#34;):
            return comma_seperated_with_and(get_role_named_elems(start_elem))
        return comma_seperated_with_and(start_elem)
    if (match_ := re.match(r&#34;.*?(\d+)$&#34;, s)) and ((idx := int(match_.group(1))) in range(_MAX_INDEX + 1)):  # index
        if hasattr(start_elem, &#34;__getitem__&#34;) and idx &lt; len(start_elem):
            return getattr(start_elem[idx], &#34;name&#34;, str(start_elem[idx]))
        warn(f&#34;&#34;&#34;parametrizedresponse.parse(): Attempted to access element {start_elem} at index {idx
              }, but the element is not a sequence or has no such index, so returning the element itself&#34;&#34;&#34;)
        return getattr(start_elem, &#34;name&#34;, str(start_elem))

    # Dot-separated properties are in the form a.b.c.d...
    # print(f&#34;parametrizedresponse.parse(): non base case s: {s}&#34;)  # TODO remove later
    dot_sep_elems = s.split(&#34;.&#34;)
    # if valid list and index, use the list element, eg, assocend0.cls means get classifier of zeroth association end
    if (isinstance(start_elem, Iterable) and (match_ := re.match(r&#34;.*?(\d+)$&#34;, dot_sep_elems[0])) and (
            idx := int(match_.group(1))) &lt; len(start_elem) and idx in range(_MAX_INDEX + 1)):
        a = start_elem[idx]
    else:
        a = start_elem
    b = dot_sep_elems[1]
    if b == &#34;length&#34;:  # special case
        if hasattr(a, &#34;__len__&#34;):
            return str(len(a))
        warn(f&#34;&#34;&#34;parametrizedresponse.parse(): Attempted to get length of element {a
              }, but the element is not a sequence, so returning the element name or string representation&#34;&#34;&#34;)
        return getattr(a, &#34;name&#34;, str(a))
    cd = dot_sep_elems[2:]
    a_dot_b = resolve_attribute(a, b)
    # print(f&#34;parametrizedresponse.parse(): [{b = }], [{&#39;.&#39;.join(cd) = }], [{a_dot_b = }]&#34;)  # TODO remove later
    return _parse(f&#34;{b}{&#39;.&#39; if cd else &#39;&#39;}{&#39;.&#39;.join(cd)}&#34;, a_dot_b, depth + 1)  # recurse to next dot-separated element


def resolve_attribute(elem, attr_name: str):
    &#34;&#34;&#34;
    Return the value of the attribute for the given element. Attribute is used here in the programmatic sense, not in
    the class diagram sense.
    &#34;&#34;&#34;
    # special cases
    match elem:
        case Association() if (match_ := re.match(r&#34;ends?(\d+)$&#34;, attr_name)):
            return elem.ends[int(match_.group(1))]
        case AssociationEnd() if attr_name in (&#34;lowerBound&#34;, &#34;upperBound&#34;):
            bound = getattr(elem, attr_name)
            return &#34;*&#34; if bound == -1 else str(bound)
        case AssociationEnd() if attr_name == &#34;refcls&#34;:
            return elem.oppositeEnd.classifier
        case Attribute() if attr_name == &#34;cls&#34;:
            return elem.eContainer()
        case Attribute() if attr_name == &#34;type&#34;:
            return elem.type.name.removeprefix(&#34;CD&#34;)

    # general case
    return getattr(elem, SHORTHANDS.get(attr_name, attr_name), elem)


def get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems(mistake: Mistake
    ) -&gt; dict[str, NamedElement | list[NamedElement]]:
    &#34;&#34;&#34;
    Return a dict of mistake element string descriptions to actual mistake elements.
    &#34;&#34;&#34;
    mt_elem_descriptions_to_diagram_elems = {}
    mt: MistakeType = mistake.mistakeType
    mt_stud: OrderedSet[MistakeElement] = mt.studentElements
    mt_inst: OrderedSet[MistakeElement] = mt.instructorElements
    for stud_key, sol_elem in zip(mt_stud[:-1], mistake.studentElements[:-1]):
        mt_elem_descriptions_to_diagram_elems[f&#34;stud_{stud_key}&#34;] = sol_elem.element
    for inst_key, sol_elem in zip(mt_inst[:-1], mistake.instructorElements[:-1]):
        mt_elem_descriptions_to_diagram_elems[f&#34;inst_{inst_key}&#34;] = sol_elem.element

    # handle the last element separately
    if mt_stud:
        if mt_stud[-1].many:
            # varargs: last student element is a list of elements, eg,
            # mistakeElems = (stud=[A, B, C*], inst=[])
            # studentElems = [a, b, c1, c2, c3, ...]
            # want studentElems[2:], which corresponds to C*, the last student element (there are 2 elems before C*)
            mt_elem_descriptions_to_diagram_elems[f&#34;stud_{mt_stud[-1]}&#34;] = [
                e.element for e in mistake.studentElements[len(mt_stud) - 1:]]
        else:
            # no varargs: last student element is a single element
            mt_elem_descriptions_to_diagram_elems[f&#34;stud_{mt_stud[-1]}&#34;] = mistake.studentElements[-1].element
    if mt_inst:
        if mt_inst[-1].many:
            mt_elem_descriptions_to_diagram_elems[f&#34;inst_{mt_inst[-1]}&#34;] = [
                e.element for e in mistake.instructorElements[len(mt_inst) - 1:]]
        else:
            mt_elem_descriptions_to_diagram_elems[f&#34;inst_{mt_inst[-1]}&#34;] = mistake.instructorElements[-1].element
    return mt_elem_descriptions_to_diagram_elems


def extract_params(pr_text: str) -&gt; list[str]:
    &#34;Return a list of parametrized response parameters.&#34;
    params = re.findall(r&#34;\$\{(?P&lt;param&gt;.*?)\}&#34;, pr_text)
    for param in params:
        if not param_valid(param):
            raise ValueError(f&#34;Invalid parametrized response parameter: {param}&#34;)
    return params


def param_parts_before_dot(params: list[str]) -&gt; list[str]:
    &#34;&#34;&#34;
    Return the list defined as

    ```js
    params.map(param =&gt; param.split(&#34;.&#34;)[0])
    ```
    &#34;&#34;&#34;
    return [param.split(&#34;.&#34;)[0] for param in params]


def comma_seperated_with_and(elems: list[NamedElement]) -&gt; str:
    &#34;&#34;&#34;
    Return a comma-seperated string of the names of the elements, with &#34;and&#34; before the last element.
    &#34;&#34;&#34;
    if not hasattr(elems, &#34;__getitem__&#34;):
        warn(f&#34;comma_seperated_with_and(): {elems} is not a sequence, returning elems.name&#34;)
        return getattr(elems, &#34;name&#34;, str(elems))
    if len(elems) == 0:
        warn(&#34;comma_seperated_with_and(): elems is empty, returning empty string&#34;)
        return &#34;&#34;
    if len(elems) == 1:
        return elems[0].name
    if len(elems) == 2:
        return f&#34;{elems[0].name} and {elems[1].name}&#34;
    if len(elems) &gt; MAX_VARARG_SEQUENCE_LENGTH:
        elems = elems[:MAX_VARARG_SEQUENCE_LENGTH]
    return f&#34;{&#39;, &#39;.join(e.name for e in elems[:-1])}, and {elems[-1].name}&#34;


def get_role_named_elems(start_elem: NamedElement | Iterable) -&gt; list[NamedElement]:
    &#34;Return a list of all Player-Role pattern roles to be displayed.&#34;
    if isinstance(start_elem, NamedElement):
        return [get_role_named_elem(start_elem)]
    roles = []
    if (isinstance(start_elem, Iterable) and not isinstance(start_elem, str)):
        for elem in start_elem:
            roles.append(get_role_named_elem(elem))
    return roles


def get_role_named_elem(start_elem: AssociationEnd | CDEnumLiteral | Classifier) -&gt; CDEnumLiteral | Classifier:
    &#34;Return a single Player-Role pattern role to be displayed.&#34;
    if isinstance(start_elem, AssociationEnd):
        return start_elem.getOppositeEnd().classifier
    return start_elem


def param_start_elem_type(param: str, as_type: type = None) -&gt; str | Metatype | EClass:
    &#34;&#34;&#34;
    Return the CDM metatype of the starting element (part before dot) of the given parametrized response parameter.

    ```
    param_start_elem_type(&#34;stud_cls&#34;) -&gt; metatypes.cls.eClass = classdiagram.Class  # default
    param_start_elem_type(&#34;stud_cls&#34;, as_type=str) -&gt; metatypes.cls.short_name = &#34;cls&#34;
    param_start_elem_type(&#34;inst_attr.type&#34;, as_type=CdmMetatype) -&gt; metatypes.attr
    ```
    &#34;&#34;&#34;
    part_before_dot = param.split(&#34;.&#34;)[0]
    type_name = re.sub(r&#34;[\d]+$&#34;, &#34;*&#34;, part_before_dot.split(&#34;_&#34;)[-1])
    if as_type == str:
        return type_name
    if as_type == Metatype:
        return metatypes.get(type_name, None)
    if as_type not in (None, EClass, type):
        warn(f&#34;param_start_elem_type(): {as_type = } is not a valid type&#34;)
    # default return value is metatypes[type_name].eClass if it exists
    return getattr(metatypes.get(type_name, None), &#34;eClass&#34;, None)


def param_valid(param: str, mt: MistakeType = None) -&gt; bool:
    &#34;&#34;&#34;
    Validate that the parameter is syntactically correct.
    The optional mistake type is used to provide a more meaningful error message if supplied.
    &#34;&#34;&#34;
    prp = &#34;Parametrized response parameter&#34;
    if mt:
        prp = f&#34;{prp} for {mt.name}&#34;
    if not isinstance(param, str) or not param:
        raise ValueError(f&#34;{prp} must be a non-empty string: `{param}`&#34;)
    if not param.startswith(&#34;stud_&#34;) and not param.startswith(&#34;inst_&#34;):
        raise ValueError(f&#34;{prp} must start with &#39;stud_&#39; or &#39;inst_&#39;: {param}&#34;)
    if &#34;__&#34; in param:
        raise ValueError(f&#34;{prp} cannot contain &#39;__&#39;: {param}&#34;)
    if param.count(&#34;*&#34;) &gt; 1:
        raise ValueError(f&#34;{prp} cannot have more than one &#39;*&#39;: {param}&#34;)
    if (param.count(&#34;.&#34;) + param.count(&#34;*&#34;) + sum(c.isdigit() for c in param)) &gt; _MAX_PARSE_DEPTH:
        raise ValueError(f&#34;{prp} cannot exceed the maximum parse depth of {_MAX_PARSE_DEPTH}: {param}&#34;)

    if not param_start_elem_type(param):
        raise ValueError(f&#34;{prp} must be a valid CDM metatype: {param}&#34;)

    return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parametrizedresponse.comma_seperated_with_and"><code class="name flex">
<span>def <span class="ident">comma_seperated_with_and</span></span>(<span>elems: list[<a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a>]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a comma-seperated string of the names of the elements, with "and" before the last element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comma_seperated_with_and(elems: list[NamedElement]) -&gt; str:
    &#34;&#34;&#34;
    Return a comma-seperated string of the names of the elements, with &#34;and&#34; before the last element.
    &#34;&#34;&#34;
    if not hasattr(elems, &#34;__getitem__&#34;):
        warn(f&#34;comma_seperated_with_and(): {elems} is not a sequence, returning elems.name&#34;)
        return getattr(elems, &#34;name&#34;, str(elems))
    if len(elems) == 0:
        warn(&#34;comma_seperated_with_and(): elems is empty, returning empty string&#34;)
        return &#34;&#34;
    if len(elems) == 1:
        return elems[0].name
    if len(elems) == 2:
        return f&#34;{elems[0].name} and {elems[1].name}&#34;
    if len(elems) &gt; MAX_VARARG_SEQUENCE_LENGTH:
        elems = elems[:MAX_VARARG_SEQUENCE_LENGTH]
    return f&#34;{&#39;, &#39;.join(e.name for e in elems[:-1])}, and {elems[-1].name}&#34;</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.extract_params"><code class="name flex">
<span>def <span class="ident">extract_params</span></span>(<span>pr_text: str) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of parametrized response parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_params(pr_text: str) -&gt; list[str]:
    &#34;Return a list of parametrized response parameters.&#34;
    params = re.findall(r&#34;\$\{(?P&lt;param&gt;.*?)\}&#34;, pr_text)
    for param in params:
        if not param_valid(param):
            raise ValueError(f&#34;Invalid parametrized response parameter: {param}&#34;)
    return params</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems"><code class="name flex">
<span>def <span class="ident">get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems</span></span>(<span>mistake: <a title="modelingassistant.modelingassistant.Mistake" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Mistake">Mistake</a>) ‑> dict[str, <a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a> | list[<a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dict of mistake element string descriptions to actual mistake elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems(mistake: Mistake
    ) -&gt; dict[str, NamedElement | list[NamedElement]]:
    &#34;&#34;&#34;
    Return a dict of mistake element string descriptions to actual mistake elements.
    &#34;&#34;&#34;
    mt_elem_descriptions_to_diagram_elems = {}
    mt: MistakeType = mistake.mistakeType
    mt_stud: OrderedSet[MistakeElement] = mt.studentElements
    mt_inst: OrderedSet[MistakeElement] = mt.instructorElements
    for stud_key, sol_elem in zip(mt_stud[:-1], mistake.studentElements[:-1]):
        mt_elem_descriptions_to_diagram_elems[f&#34;stud_{stud_key}&#34;] = sol_elem.element
    for inst_key, sol_elem in zip(mt_inst[:-1], mistake.instructorElements[:-1]):
        mt_elem_descriptions_to_diagram_elems[f&#34;inst_{inst_key}&#34;] = sol_elem.element

    # handle the last element separately
    if mt_stud:
        if mt_stud[-1].many:
            # varargs: last student element is a list of elements, eg,
            # mistakeElems = (stud=[A, B, C*], inst=[])
            # studentElems = [a, b, c1, c2, c3, ...]
            # want studentElems[2:], which corresponds to C*, the last student element (there are 2 elems before C*)
            mt_elem_descriptions_to_diagram_elems[f&#34;stud_{mt_stud[-1]}&#34;] = [
                e.element for e in mistake.studentElements[len(mt_stud) - 1:]]
        else:
            # no varargs: last student element is a single element
            mt_elem_descriptions_to_diagram_elems[f&#34;stud_{mt_stud[-1]}&#34;] = mistake.studentElements[-1].element
    if mt_inst:
        if mt_inst[-1].many:
            mt_elem_descriptions_to_diagram_elems[f&#34;inst_{mt_inst[-1]}&#34;] = [
                e.element for e in mistake.instructorElements[len(mt_inst) - 1:]]
        else:
            mt_elem_descriptions_to_diagram_elems[f&#34;inst_{mt_inst[-1]}&#34;] = mistake.instructorElements[-1].element
    return mt_elem_descriptions_to_diagram_elems</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.get_role_named_elem"><code class="name flex">
<span>def <span class="ident">get_role_named_elem</span></span>(<span>start_elem: <a title="classdiagram.classdiagram.AssociationEnd" href="classdiagram/classdiagram.html#classdiagram.classdiagram.AssociationEnd">AssociationEnd</a> | <a title="classdiagram.classdiagram.CDEnumLiteral" href="classdiagram/classdiagram.html#classdiagram.classdiagram.CDEnumLiteral">CDEnumLiteral</a> | <a title="classdiagram.classdiagram.Classifier" href="classdiagram/classdiagram.html#classdiagram.classdiagram.Classifier">Classifier</a>) ‑> <a title="classdiagram.classdiagram.CDEnumLiteral" href="classdiagram/classdiagram.html#classdiagram.classdiagram.CDEnumLiteral">CDEnumLiteral</a> | <a title="classdiagram.classdiagram.Classifier" href="classdiagram/classdiagram.html#classdiagram.classdiagram.Classifier">Classifier</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a single Player-Role pattern role to be displayed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_named_elem(start_elem: AssociationEnd | CDEnumLiteral | Classifier) -&gt; CDEnumLiteral | Classifier:
    &#34;Return a single Player-Role pattern role to be displayed.&#34;
    if isinstance(start_elem, AssociationEnd):
        return start_elem.getOppositeEnd().classifier
    return start_elem</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.get_role_named_elems"><code class="name flex">
<span>def <span class="ident">get_role_named_elems</span></span>(<span>start_elem: <a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a> | collections.abc.Iterable) ‑> list[<a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all Player-Role pattern roles to be displayed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_role_named_elems(start_elem: NamedElement | Iterable) -&gt; list[NamedElement]:
    &#34;Return a list of all Player-Role pattern roles to be displayed.&#34;
    if isinstance(start_elem, NamedElement):
        return [get_role_named_elem(start_elem)]
    roles = []
    if (isinstance(start_elem, Iterable) and not isinstance(start_elem, str)):
        for elem in start_elem:
            roles.append(get_role_named_elem(elem))
    return roles</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.param_parts_before_dot"><code class="name flex">
<span>def <span class="ident">param_parts_before_dot</span></span>(<span>params: list[str]) ‑> list[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the list defined as</p>
<pre><code class="language-js">params.map(param =&gt; param.split(&quot;.&quot;)[0])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_parts_before_dot(params: list[str]) -&gt; list[str]:
    &#34;&#34;&#34;
    Return the list defined as

    ```js
    params.map(param =&gt; param.split(&#34;.&#34;)[0])
    ```
    &#34;&#34;&#34;
    return [param.split(&#34;.&#34;)[0] for param in params]</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.param_start_elem_type"><code class="name flex">
<span>def <span class="ident">param_start_elem_type</span></span>(<span>param: str, as_type: type = None) ‑> str | <a title="metatypes.Metatype" href="metatypes.html#metatypes.Metatype">Metatype</a> | pyecore.ecore.EClass</span>
</code></dt>
<dd>
<div class="desc"><p>Return the CDM metatype of the starting element (part before dot) of the given parametrized response parameter.</p>
<pre><code>param_start_elem_type(&quot;stud_cls&quot;) -&gt; metatypes.cls.eClass = classdiagram.Class  # default
param_start_elem_type(&quot;stud_cls&quot;, as_type=str) -&gt; metatypes.cls.short_name = &quot;cls&quot;
param_start_elem_type(&quot;inst_attr.type&quot;, as_type=CdmMetatype) -&gt; metatypes.attr
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_start_elem_type(param: str, as_type: type = None) -&gt; str | Metatype | EClass:
    &#34;&#34;&#34;
    Return the CDM metatype of the starting element (part before dot) of the given parametrized response parameter.

    ```
    param_start_elem_type(&#34;stud_cls&#34;) -&gt; metatypes.cls.eClass = classdiagram.Class  # default
    param_start_elem_type(&#34;stud_cls&#34;, as_type=str) -&gt; metatypes.cls.short_name = &#34;cls&#34;
    param_start_elem_type(&#34;inst_attr.type&#34;, as_type=CdmMetatype) -&gt; metatypes.attr
    ```
    &#34;&#34;&#34;
    part_before_dot = param.split(&#34;.&#34;)[0]
    type_name = re.sub(r&#34;[\d]+$&#34;, &#34;*&#34;, part_before_dot.split(&#34;_&#34;)[-1])
    if as_type == str:
        return type_name
    if as_type == Metatype:
        return metatypes.get(type_name, None)
    if as_type not in (None, EClass, type):
        warn(f&#34;param_start_elem_type(): {as_type = } is not a valid type&#34;)
    # default return value is metatypes[type_name].eClass if it exists
    return getattr(metatypes.get(type_name, None), &#34;eClass&#34;, None)</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.param_valid"><code class="name flex">
<span>def <span class="ident">param_valid</span></span>(<span>param: str, mt: <a title="learningcorpus.learningcorpus.MistakeType" href="learningcorpus/learningcorpus.html#learningcorpus.learningcorpus.MistakeType">MistakeType</a> = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate that the parameter is syntactically correct.
The optional mistake type is used to provide a more meaningful error message if supplied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_valid(param: str, mt: MistakeType = None) -&gt; bool:
    &#34;&#34;&#34;
    Validate that the parameter is syntactically correct.
    The optional mistake type is used to provide a more meaningful error message if supplied.
    &#34;&#34;&#34;
    prp = &#34;Parametrized response parameter&#34;
    if mt:
        prp = f&#34;{prp} for {mt.name}&#34;
    if not isinstance(param, str) or not param:
        raise ValueError(f&#34;{prp} must be a non-empty string: `{param}`&#34;)
    if not param.startswith(&#34;stud_&#34;) and not param.startswith(&#34;inst_&#34;):
        raise ValueError(f&#34;{prp} must start with &#39;stud_&#39; or &#39;inst_&#39;: {param}&#34;)
    if &#34;__&#34; in param:
        raise ValueError(f&#34;{prp} cannot contain &#39;__&#39;: {param}&#34;)
    if param.count(&#34;*&#34;) &gt; 1:
        raise ValueError(f&#34;{prp} cannot have more than one &#39;*&#39;: {param}&#34;)
    if (param.count(&#34;.&#34;) + param.count(&#34;*&#34;) + sum(c.isdigit() for c in param)) &gt; _MAX_PARSE_DEPTH:
        raise ValueError(f&#34;{prp} cannot exceed the maximum parse depth of {_MAX_PARSE_DEPTH}: {param}&#34;)

    if not param_start_elem_type(param):
        raise ValueError(f&#34;{prp} must be a valid CDM metatype: {param}&#34;)

    return True</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.parametrize_response"><code class="name flex">
<span>def <span class="ident">parametrize_response</span></span>(<span>response: <a title="learningcorpus.learningcorpus.ParametrizedResponse" href="learningcorpus/learningcorpus.html#learningcorpus.learningcorpus.ParametrizedResponse">ParametrizedResponse</a>, mistake: <a title="modelingassistant.modelingassistant.Mistake" href="modelingassistant/modelingassistant.html#modelingassistant.modelingassistant.Mistake">Mistake</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the filled-in parametrized response text for the given response and mistake.</p>
<p>This function uses the following approach to determing the returned text:</p>
<ol>
<li>Map mistake type element descriptions to mistake elements</li>
<li>Extract parameter template strings from parametrized response text, eg, ${stud_attr.cls}</li>
<li>Get parameter part before dot, eg, stud_attr. This is the start element, passed into the parse() function</li>
<li>Populate the options dictionary with (original parameter, replacement) pairs</li>
<li>Use the Python string formatter to replace the parameter template strings with the corresponding values</li>
</ol>
<p>Example execution (Python-like pseudocode):</p>
<pre><code>Given MistakeType WRONG_CLASS_NAME with student element cls and instructor element cls:
parametrize_response(resp=&quot;${stud_cls} should be ${inst_cls}.&quot;, mistake={mt: WRONG_CLASS_NAME, se: [sc], ie: [ic]}):
    1. Establish mapping {stud_cls: sc, inst_cls: ic}
    2. Extract parameters: stud_cls, inst_cls
    3. Get part before dot: stud_cls, inst_cls (no change for this example)
    4. Populate options by calling parse() for each one: {stud_cls: sc, inst_cls: ic}
    5. Return resulting string with replacements: &quot;sc should be ic.&quot;
</code></pre>
<p>For other more interesting examples, see the unit tests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parametrize_response(response: ParametrizedResponse, mistake: Mistake) -&gt; str:
    &#34;&#34;&#34;
    Return the filled-in parametrized response text for the given response and mistake.

    This function uses the following approach to determing the returned text:

    1. Map mistake type element descriptions to mistake elements
    2. Extract parameter template strings from parametrized response text, eg, ${stud_attr.cls}
    3. Get parameter part before dot, eg, stud_attr. This is the start element, passed into the parse() function
    4. Populate the options dictionary with (original parameter, replacement) pairs
    5. Use the Python string formatter to replace the parameter template strings with the corresponding values

    Example execution (Python-like pseudocode):

    ```
    Given MistakeType WRONG_CLASS_NAME with student element cls and instructor element cls:
    parametrize_response(resp=&#34;${stud_cls} should be ${inst_cls}.&#34;, mistake={mt: WRONG_CLASS_NAME, se: [sc], ie: [ic]}):
        1. Establish mapping {stud_cls: sc, inst_cls: ic}
        2. Extract parameters: stud_cls, inst_cls
        3. Get part before dot: stud_cls, inst_cls (no change for this example)
        4. Populate options by calling parse() for each one: {stud_cls: sc, inst_cls: ic}
        5. Return resulting string with replacements: &#34;sc should be ic.&#34;
    ```

    For other more interesting examples, see the unit tests.
    &#34;&#34;&#34;
    options: dict[str, str] = {}
    mt_elem_descriptions_to_mistake_elems = get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems(mistake)
    params = extract_params(response.text)
    param_roots = param_parts_before_dot(params)
    for param, param_root in zip(params, param_roots):
        start_elem = mt_elem_descriptions_to_mistake_elems.get(param_root)
        if start_elem is None:
            warn(f&#34;parametrizedresponse.parametrize_response(): Parameter {param} not found for mistake {mistake}&#34;)
            continue
        options[param] = parse(param, start_elem)
    # print(f&#34;parametrizedresponse.parametrize_response(): {options = }&#34;)  # TODO remove later
    resp_text: str = response.text.replace(&#34;$&#34;, &#34;&#34;)  # remove all $ from the response text
    for t in _formatter.parse(resp_text):  # not to be confused with the parse() function defined below
        # print(f&#34;parametrizedresponse.parametrize_response(): {t = }&#34;)  # TODO remove later
        if t[1] is not None:
            resp_text = resp_text.replace(f&#34;{{{t[1]}}}&#34;, options[t[1]], 1)
    return resp_text</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>s: str, start_elem: <a title="classdiagram.classdiagram.NamedElement" href="classdiagram/classdiagram.html#classdiagram.classdiagram.NamedElement">NamedElement</a>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively parse a parameter from a parametrized response string, as applied on the input starting element.
The format of the parameter is as follows:</p>
<pre><code>('stud'|'inst')_[description_]elementtype[('*'|index)][.elementproperty[('*'|index)]]*
</code></pre>
<ul>
<li>elementtype is a CDM metatype.</li>
<li>description is a string that provides more information about the parameter, eg, inst_super_cls.
It is needed whenever there is more than one parameter with the same person (stud/inst) and the same type</li>
<li>index is an integer, used to get the nth element of a sequence where applicable, eg, inst_assocend0</li>
<li>elementproperty is a property (field) defined on an element at the metamodel level
or a predefined shorthand for it like 'cls'</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(s: str, start_elem: NamedElement) -&gt; str:
    &#34;&#34;&#34;
    Recursively parse a parameter from a parametrized response string, as applied on the input starting element.
    The format of the parameter is as follows:

    ```
    (&#39;stud&#39;|&#39;inst&#39;)_[description_]elementtype[(&#39;*&#39;|index)][.elementproperty[(&#39;*&#39;|index)]]*
    ```

    - elementtype is a CDM metatype.
    - description is a string that provides more information about the parameter, eg, inst_super_cls.
    It is needed whenever there is more than one parameter with the same person (stud/inst) and the same type
    - index is an integer, used to get the nth element of a sequence where applicable, eg, inst_assocend0
    - elementproperty is a property (field) defined on an element at the metamodel level
    or a predefined shorthand for it like &#39;cls&#39;
    &#34;&#34;&#34;
    if not param_valid(s):
        raise ValueError(f&#34;Invalid parametrized response parameter: {s}&#34;)
    return _parse(s, start_elem)  # call internal helper function to do actual parsing</code></pre>
</details>
</dd>
<dt id="parametrizedresponse.resolve_attribute"><code class="name flex">
<span>def <span class="ident">resolve_attribute</span></span>(<span>elem, attr_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the attribute for the given element. Attribute is used here in the programmatic sense, not in
the class diagram sense.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_attribute(elem, attr_name: str):
    &#34;&#34;&#34;
    Return the value of the attribute for the given element. Attribute is used here in the programmatic sense, not in
    the class diagram sense.
    &#34;&#34;&#34;
    # special cases
    match elem:
        case Association() if (match_ := re.match(r&#34;ends?(\d+)$&#34;, attr_name)):
            return elem.ends[int(match_.group(1))]
        case AssociationEnd() if attr_name in (&#34;lowerBound&#34;, &#34;upperBound&#34;):
            bound = getattr(elem, attr_name)
            return &#34;*&#34; if bound == -1 else str(bound)
        case AssociationEnd() if attr_name == &#34;refcls&#34;:
            return elem.oppositeEnd.classifier
        case Attribute() if attr_name == &#34;cls&#34;:
            return elem.eContainer()
        case Attribute() if attr_name == &#34;type&#34;:
            return elem.type.name.removeprefix(&#34;CD&#34;)

    # general case
    return getattr(elem, SHORTHANDS.get(attr_name, attr_name), elem)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parametrizedresponse.comma_seperated_with_and" href="#parametrizedresponse.comma_seperated_with_and">comma_seperated_with_and</a></code></li>
<li><code><a title="parametrizedresponse.extract_params" href="#parametrizedresponse.extract_params">extract_params</a></code></li>
<li><code><a title="parametrizedresponse.get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems" href="#parametrizedresponse.get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems">get_mapping_from_mistake_elem_descriptions_to_actual_mistake_elems</a></code></li>
<li><code><a title="parametrizedresponse.get_role_named_elem" href="#parametrizedresponse.get_role_named_elem">get_role_named_elem</a></code></li>
<li><code><a title="parametrizedresponse.get_role_named_elems" href="#parametrizedresponse.get_role_named_elems">get_role_named_elems</a></code></li>
<li><code><a title="parametrizedresponse.param_parts_before_dot" href="#parametrizedresponse.param_parts_before_dot">param_parts_before_dot</a></code></li>
<li><code><a title="parametrizedresponse.param_start_elem_type" href="#parametrizedresponse.param_start_elem_type">param_start_elem_type</a></code></li>
<li><code><a title="parametrizedresponse.param_valid" href="#parametrizedresponse.param_valid">param_valid</a></code></li>
<li><code><a title="parametrizedresponse.parametrize_response" href="#parametrizedresponse.parametrize_response">parametrize_response</a></code></li>
<li><code><a title="parametrizedresponse.parse" href="#parametrizedresponse.parse">parse</a></code></li>
<li><code><a title="parametrizedresponse.resolve_attribute" href="#parametrizedresponse.resolve_attribute">resolve_attribute</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>