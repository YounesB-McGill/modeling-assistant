<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>user API documentation</title>
<meta name="description" content="Module to manage users." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>user</code></h1>
</header>
<section id="section-intro">
<p>Module to manage users.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module to manage users.
&#34;&#34;&#34;

from __future__ import annotations

import logging
import random
import secrets
from random import randint
from string import ascii_lowercase
from time import time
from typing import Literal

import requests

from constants import WEBCORE_ENDPOINT
from feedback import FeedbackTO
from modelingassistantapp import LOGGING_FORMAT, LOGGING_LEVEL
from utils import cdm_diff, to_simplenamespace, warn, ClassDiagramDTO, AeReferenceType

USER_REGISTER_ENDPOINT = f&#34;{WEBCORE_ENDPOINT}/user/public/register&#34;
USER_LOGIN_ENDPOINT = f&#34;{WEBCORE_ENDPOINT}/user/public/login&#34;
USER_LOGOUT_ENDPOINT = f&#34;{WEBCORE_ENDPOINT}/user/logout&#34;

_USERNAME_PREFIX_LENGTH = 6

users: dict[str, User] = {}

logging.basicConfig(level=LOGGING_LEVEL, format=LOGGING_FORMAT)
logger = logging.getLogger(__name__)

class User:
    &#34;Class to represent a user.&#34;
    def __init__(self, name: str, password):
        &#34;Register a new user.&#34;
        if name in users:
            raise ValueError(f&#34;Username {name} already exists.&#34;)
        self.name = name
        self.password = password
        self.token = self.get_token()
        self._logged_in = False
        users[name] = self

    def get_token(self):
        &#34;Get the user&#39;s token.&#34;
        response = requests.put(USER_REGISTER_ENDPOINT, json=self._auth_creds)
        if not response.ok:
            raise ValueError(f&#34;Could not get token for user {self.name}.\nError: {response.text}&#34;)
        return response.text.strip().removeprefix(&#34;User registered. Your authorization token is &#39;&#34;).removesuffix(
            &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)

    def login(self) -&gt; bool:
        &#34;Login the user and update their token if needed.&#34;
        response = requests.post(USER_LOGIN_ENDPOINT, headers=self._auth_header, json=self._auth_creds)
        if not response.ok:
            return False
        self.token = response.text.strip().removeprefix(&#34;Logged in. Your authorization token is &#39;&#34;).removesuffix(
            &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)
        self._logged_in = True
        return True

    def logout(self) -&gt; bool:
        &#34;Logout the user.&#34;
        response = requests.post(USER_LOGOUT_ENDPOINT, headers=self._auth_header)
        if not response.ok:
            return False
        del self.token  # token invalidated in WebCORE, so get rid of here on the client side as well
        self._logged_in = False
        return True

    @property
    def logged_in(self):
        &#34;Return True if the user is logged in.&#34;
        return self._logged_in

    @property
    def _auth_creds(self):
        &#34;Return the user&#39;s authorization credentials.&#34;
        return {&#34;username&#34;: self.name, &#34;password&#34;: self.password}

    @property
    def _auth_header(self):
        &#34;Get the user&#39;s authorization header.&#34;
        return {&#34;Authorization&#34;: f&#34;Bearer {self.token}&#34;} if hasattr(self, &#34;token&#34;) else {}

    @classmethod
    def create_random(cls):
        &#34;Create a user with a random name and password, useful for testing.&#34;
        # fully ensure unique name for new user by using current timestamp
        name = f&#34;{&#39;&#39;.join(random.sample(ascii_lowercase, _USERNAME_PREFIX_LENGTH))}{int(time())}&#34;
        password = secrets.token_urlsafe(16)
        return cls(name, password)  # use cls here to allow the creation of User subclasses

    def __repr__(self) -&gt; str:
        # TODO token returned for debugging only, remove before release
        return f&#39;{self.__class__.__name__}(name=&#34;{self.name}&#34;, token=&#34;{self.token}&#34;)&#39;


class MockStudent(User):
    &#34;&#34;&#34;
    Mock student used for testing.
    This represents a student who only interacts with the application via the frontend.
    &#34;&#34;&#34;
    def __init__(self, name: str, password):
        super().__init__(name, password)
        self.student = None  # possible pointer to a Student metamodel instance for future integration tests
        self._cdm: ClassDiagramDTO = None  # internal CDM cache to minimize requests to WebCORE

    def create_cdm(self, name: str) -&gt; bool:
        &#34;Create a student class diagram.&#34;
        resp = requests.put(self.cdm_endpoint(name), headers=self._auth_header)
        return resp.ok

    def create_class(self, cdm_name: str, cls_name: str) -&gt; str:
        &#34;Create a class with the given name in the given class diagram belonging to the student and return its _id.&#34;
        old_cdm = self.get_cdm(cdm_name)
        old_class_mapping = old_cdm.get_class_names_by_ids()
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class&#34;, headers=self._auth_header,
                             json={&#34;className&#34;: cls_name, &#34;dataType&#34;: False, &#34;isInterface&#34;: False,
                                   &#34;x&#34;: randint(0, 600), &#34;y&#34;: randint(0, 600)})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        new_cdm_mapping = new_cdm.get_class_names_by_ids()
        new_ids: set[str] = new_cdm_mapping.keys() - old_class_mapping
        if len(new_ids) != 1:
            warn(f&#34;MockStudent.create_class(): The number of new _ids is {len(new_ids)} instead of 1.&#34;)
        cls_id = new_ids.pop()
        logger.debug(f&#34;MockStudent: Created class with _id {cls_id}&#34;)
        return cls_id

    def delete_class(self, cdm_name: str, cls_id: str):
        &#34;Delete the class with the given _id from the given class diagram belonging to the student.&#34;
        resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}&#34;, headers=self._auth_header)
        resp.raise_for_status()

    def create_attribute(self, cdm_name: str, cls_id: str, attr_name: str, attr_type: type | str) -&gt; str:
        &#34;Create an attribute with the given name and return its _id.&#34;
        old_cdm = self.get_cdm(cdm_name)
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}/attribute&#34;, headers=self._auth_header,
                             json={&#34;rankIndex&#34;: 0, &#34;typeId&#34;: old_cdm.type_id_for(attr_type),
                                   &#34;attributeName&#34;: attr_name})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        logger.debug(cdm_diff(old_cdm, new_cdm))
        attr_id = cdm_diff(old_cdm, new_cdm).additions[0]
        logger.debug(f&#34;MockStudent.create_attribute(): Returning {attr_id = }&#34;)
        return attr_id

    def delete_attribute(self, cdm_name: str, attr_id: str):
        &#34;Delete the attribute from the given class.&#34;
        resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/attribute/{attr_id}&#34;,
                               headers=self._auth_header)
        resp.raise_for_status()

    def create_generalization(self, cdm_name: str, subclass_id: str, superclass_id: str) -&gt; tuple[str, str]:
        &#34;Create a generalization between the given subclass and superclass and return their _id&#39;s in that order.&#34;
        old_class_names = self._cdm.get_class_names_by_ids()
        subclass_name = old_class_names[subclass_id]
        superclass_name = old_class_names[superclass_id]
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association/supertype&#34;, headers=self._auth_header,
                                json={&#34;subClassId&#34;: subclass_id, &#34;superClassId&#34;: superclass_id})
        resp.raise_for_status()
        # The _ids of the subclass and superclass may change, so we need a 2nd API call to GET the new ones
        new_class_ids = self.get_cdm(cdm_name).get_ids_by_class_names()
        subclass_id = new_class_ids[subclass_name]
        superclass_id = new_class_ids[superclass_name]
        return subclass_id, superclass_id

    def create_association(self, cdm_name: str,
        multiplicities1: int | tuple[int, int] = 1, class1_id: str = &#34;&#34;, rolename1: str = &#34;&#34;,
        multiplicities2: int | tuple[int, int] = 1, class2_id: str = &#34;&#34;, rolename2: str = &#34;&#34;,
        bidirectional: bool = True, reftype1: AeReferenceType = &#34;Regular&#34;, reftype2: AeReferenceType = &#34;Regular&#34;
    ) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create an association with the given inputs, which are ordered in mostly the same way as Umple:

        multiplicities1, class1_id, rolename1, multiplicities2, class2_id, rolename2, bidrectional, reftype1, reftype2

        (The last three arguments are at the end because they are optional.)

        For example:

            1..2   Pilot      pilots  --   *   Airplane      airplanes

        -&gt; (1, 2), pilot_id, &#34;pilots&#34;,   MANY, airplane_id, &#34;airplanes&#34;, Regular, Regular

        The return value is a 5-tuple: (class1_id, ae1_id, assoc_id, ae2_id, class2_id).
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments, too-many-locals, protected-access
        def value_or_index(element: int | tuple[int, int], index=0) -&gt; int:
            return element if isinstance(element, int) else element[index]

        if not class1_id or not class2_id:
            raise ValueError(f&#34;MockStudent.create_association(): {class1_id = } and/or {class2_id = } not valid.&#34;)
        # AssociationEnd lower and upper bounds
        ae1lb, ae1ub = value_or_index(multiplicities1), value_or_index(multiplicities1, 1)  # eg,  1,  2
        ae2lb, ae2ub = value_or_index(multiplicities2), value_or_index(multiplicities2, 1)  # eg, -1, -1
        old_class_names = self._cdm.get_class_names_by_ids()
        class1_name = old_class_names[class1_id]
        class2_name = old_class_names[class2_id]
        old_assoc_mapping = self._cdm.get_associations_by_ids()
        # Rudimentary pluralization when upper bound is 2+ or -1 (*)
        rolename1 = rolename1 or f&#34;{class1_name[0].lower()}{class1_name[1:]}{&#39;s&#39; if ae1ub != 1 else &#39;&#39;}&#34;  # eg, pilots
        rolename2 = rolename2 or f&#34;{class2_name[0].lower()}{class2_name[1:]}{&#39;s&#39; if ae2ub != 1 else &#39;&#39;}&#34;  # eg, airpl.

        # Create the association itself
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association&#34;, headers=self._auth_header,
                             json={&#34;fromClassId&#34;: class1_id, &#34;toClassId&#34;: class2_id, &#34;bidirectional&#34;: bidirectional})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        ids_by_class_names = new_cdm.get_ids_by_class_names()
        class1_id = ids_by_class_names[class1_name]
        class2_id = ids_by_class_names[class2_name]
        class2_ae_ids = [ae._id for ae in new_cdm[class2_id].associationEnds]
        new_assoc_mapping = new_cdm.get_associations_by_ids()
        new_assoc_ids: set[str] = new_assoc_mapping.keys() - old_assoc_mapping
        if len(new_assoc_ids) != 1:
            warn(f&#34;MockStudent.create_association(): The number of new _ids is {len(new_assoc_ids)} instead of 1.&#34;)
        assoc_id = new_assoc_ids.pop()
        assoc_end_ids: list[str] = new_cdm[assoc_id].ends
        # ae1 here means the association end that refers to class1 and is contained in class2
        ae1 = assoc_end_ids[0] if assoc_end_ids[0] in class2_ae_ids else assoc_end_ids[1]  # eg, Airplane.pilots
        ae2 = assoc_end_ids[0] if assoc_end_ids[0] != ae1 else assoc_end_ids[1]            # eg, Pilot.airplanes

        # Set the multiplicities of the association ends if different from 1 (the default)
        for ae, lb, ub in ((ae1, ae1lb, ae1ub), (ae2, ae2lb, ae2ub)):
            if not lb == ub == 1:  # if both are 1, save an API call
                resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/multiplicity&#34;,
                                    headers=self._auth_header, json={&#34;lowerBound&#34;: lb, &#34;upperBound&#34;: ub})
                resp.raise_for_status()

        # Set the rolenames of the association ends
        for ae, rolename in ((ae1, rolename1), (ae2, rolename2)):
            resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/rolename&#34;,
                                headers=self._auth_header, json={&#34;roleName&#34;: rolename})
            resp.raise_for_status()

        # Set the reference types of the association ends if not Regular (the default)
        for ae, reftype in ((ae1, reftype1), (ae2, reftype2)):
            if reftype != &#34;Regular&#34;:
                resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/referencetype&#34;,
                                    headers=self._auth_header, json={&#34;referenceType&#34;: reftype})
                resp.raise_for_status()

        # eg, Pilot, Airplane.pilots, Pilot_Airplane, Pilot.airplanes, Airplane
        return (class1_id, ae1, assoc_id, ae2, class2_id)

    def create_composition(self, cdm_name: str,
        whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
        whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
        part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create a composition with the given inputs and return a 5-tuple,
        (whole_class_id, whole_ae_id, compos_id, part_ae_id, part_class_id). See create_association() for parameter
        details. Note that the AssociationEnd with the part_rolename refers to the Part class and is contained in the
        Whole class and has the Composition ReferenceType.

        Example:
        ```
        1  Car car &lt;@&gt;- 1 Engine engine
        |   |   |       |    |      |
        |   |   |       |  Part     |
        |   |   |       |           |
        | Whole | part_multiplicity |
        |       |                   |
        |  whole_rolename           |
        |                           |
        whole_multiplicity    part_rolename (composend)
        ```
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments
        return self.create_association(
            cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
            part_rolename, bidirectional, &#34;Regular&#34;, &#34;Composition&#34;)

    def create_aggregation(self, cdm_name: str,
        whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
        whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
        part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create an aggregation with the given inputs and return a 5-tuple,
        (whole_class_id, whole_ae_id, aggr_id, part_ae_id, part_class_id). See the methods above for parameter details.
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments
        return self.create_association(
            cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
            part_rolename, bidirectional, &#34;Regular&#34;, &#34;Aggregation&#34;)

    def request_feedback(self, cdm_name: str) -&gt; FeedbackTO:
        &#34;Request feedback from the Modeling Assistant via WebCORE.&#34;
        resp = requests.get(f&#34;{self.cdm_endpoint(cdm_name)}/feedback&#34;, headers=self._auth_header)
        print(f&#34;{resp.text = }&#34;)
        resp.raise_for_status()
        feedback_json = resp.json()
        return FeedbackTO(**feedback_json)

    def get_cdm(self, cdm_name: str) -&gt; ClassDiagramDTO:
        &#34;Get the student&#39;s class diagram with the given name from WebCORE in JSON format.&#34;
        resp = requests.get(self.cdm_endpoint(cdm_name), headers=self._auth_header)
        resp.raise_for_status()
        self._cdm = ClassDiagramDTO(resp.json(object_hook=to_simplenamespace))
        logger.debug(self._cdm)
        return self._cdm

    def cdm_endpoint(self, cdm_name: str) -&gt; str:
        &#34;Return the class diagram endpoint for the student with the given name.&#34;
        return f&#34;{WEBCORE_ENDPOINT}/{self.name}/classdiagram/{cdm_name}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="user.MockStudent"><code class="flex name class">
<span>class <span class="ident">MockStudent</span></span>
<span>(</span><span>name: str, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Mock student used for testing.
This represents a student who only interacts with the application via the frontend.</p>
<p>Register a new user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MockStudent(User):
    &#34;&#34;&#34;
    Mock student used for testing.
    This represents a student who only interacts with the application via the frontend.
    &#34;&#34;&#34;
    def __init__(self, name: str, password):
        super().__init__(name, password)
        self.student = None  # possible pointer to a Student metamodel instance for future integration tests
        self._cdm: ClassDiagramDTO = None  # internal CDM cache to minimize requests to WebCORE

    def create_cdm(self, name: str) -&gt; bool:
        &#34;Create a student class diagram.&#34;
        resp = requests.put(self.cdm_endpoint(name), headers=self._auth_header)
        return resp.ok

    def create_class(self, cdm_name: str, cls_name: str) -&gt; str:
        &#34;Create a class with the given name in the given class diagram belonging to the student and return its _id.&#34;
        old_cdm = self.get_cdm(cdm_name)
        old_class_mapping = old_cdm.get_class_names_by_ids()
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class&#34;, headers=self._auth_header,
                             json={&#34;className&#34;: cls_name, &#34;dataType&#34;: False, &#34;isInterface&#34;: False,
                                   &#34;x&#34;: randint(0, 600), &#34;y&#34;: randint(0, 600)})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        new_cdm_mapping = new_cdm.get_class_names_by_ids()
        new_ids: set[str] = new_cdm_mapping.keys() - old_class_mapping
        if len(new_ids) != 1:
            warn(f&#34;MockStudent.create_class(): The number of new _ids is {len(new_ids)} instead of 1.&#34;)
        cls_id = new_ids.pop()
        logger.debug(f&#34;MockStudent: Created class with _id {cls_id}&#34;)
        return cls_id

    def delete_class(self, cdm_name: str, cls_id: str):
        &#34;Delete the class with the given _id from the given class diagram belonging to the student.&#34;
        resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}&#34;, headers=self._auth_header)
        resp.raise_for_status()

    def create_attribute(self, cdm_name: str, cls_id: str, attr_name: str, attr_type: type | str) -&gt; str:
        &#34;Create an attribute with the given name and return its _id.&#34;
        old_cdm = self.get_cdm(cdm_name)
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}/attribute&#34;, headers=self._auth_header,
                             json={&#34;rankIndex&#34;: 0, &#34;typeId&#34;: old_cdm.type_id_for(attr_type),
                                   &#34;attributeName&#34;: attr_name})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        logger.debug(cdm_diff(old_cdm, new_cdm))
        attr_id = cdm_diff(old_cdm, new_cdm).additions[0]
        logger.debug(f&#34;MockStudent.create_attribute(): Returning {attr_id = }&#34;)
        return attr_id

    def delete_attribute(self, cdm_name: str, attr_id: str):
        &#34;Delete the attribute from the given class.&#34;
        resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/attribute/{attr_id}&#34;,
                               headers=self._auth_header)
        resp.raise_for_status()

    def create_generalization(self, cdm_name: str, subclass_id: str, superclass_id: str) -&gt; tuple[str, str]:
        &#34;Create a generalization between the given subclass and superclass and return their _id&#39;s in that order.&#34;
        old_class_names = self._cdm.get_class_names_by_ids()
        subclass_name = old_class_names[subclass_id]
        superclass_name = old_class_names[superclass_id]
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association/supertype&#34;, headers=self._auth_header,
                                json={&#34;subClassId&#34;: subclass_id, &#34;superClassId&#34;: superclass_id})
        resp.raise_for_status()
        # The _ids of the subclass and superclass may change, so we need a 2nd API call to GET the new ones
        new_class_ids = self.get_cdm(cdm_name).get_ids_by_class_names()
        subclass_id = new_class_ids[subclass_name]
        superclass_id = new_class_ids[superclass_name]
        return subclass_id, superclass_id

    def create_association(self, cdm_name: str,
        multiplicities1: int | tuple[int, int] = 1, class1_id: str = &#34;&#34;, rolename1: str = &#34;&#34;,
        multiplicities2: int | tuple[int, int] = 1, class2_id: str = &#34;&#34;, rolename2: str = &#34;&#34;,
        bidirectional: bool = True, reftype1: AeReferenceType = &#34;Regular&#34;, reftype2: AeReferenceType = &#34;Regular&#34;
    ) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create an association with the given inputs, which are ordered in mostly the same way as Umple:

        multiplicities1, class1_id, rolename1, multiplicities2, class2_id, rolename2, bidrectional, reftype1, reftype2

        (The last three arguments are at the end because they are optional.)

        For example:

            1..2   Pilot      pilots  --   *   Airplane      airplanes

        -&gt; (1, 2), pilot_id, &#34;pilots&#34;,   MANY, airplane_id, &#34;airplanes&#34;, Regular, Regular

        The return value is a 5-tuple: (class1_id, ae1_id, assoc_id, ae2_id, class2_id).
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments, too-many-locals, protected-access
        def value_or_index(element: int | tuple[int, int], index=0) -&gt; int:
            return element if isinstance(element, int) else element[index]

        if not class1_id or not class2_id:
            raise ValueError(f&#34;MockStudent.create_association(): {class1_id = } and/or {class2_id = } not valid.&#34;)
        # AssociationEnd lower and upper bounds
        ae1lb, ae1ub = value_or_index(multiplicities1), value_or_index(multiplicities1, 1)  # eg,  1,  2
        ae2lb, ae2ub = value_or_index(multiplicities2), value_or_index(multiplicities2, 1)  # eg, -1, -1
        old_class_names = self._cdm.get_class_names_by_ids()
        class1_name = old_class_names[class1_id]
        class2_name = old_class_names[class2_id]
        old_assoc_mapping = self._cdm.get_associations_by_ids()
        # Rudimentary pluralization when upper bound is 2+ or -1 (*)
        rolename1 = rolename1 or f&#34;{class1_name[0].lower()}{class1_name[1:]}{&#39;s&#39; if ae1ub != 1 else &#39;&#39;}&#34;  # eg, pilots
        rolename2 = rolename2 or f&#34;{class2_name[0].lower()}{class2_name[1:]}{&#39;s&#39; if ae2ub != 1 else &#39;&#39;}&#34;  # eg, airpl.

        # Create the association itself
        resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association&#34;, headers=self._auth_header,
                             json={&#34;fromClassId&#34;: class1_id, &#34;toClassId&#34;: class2_id, &#34;bidirectional&#34;: bidirectional})
        resp.raise_for_status()
        new_cdm = self.get_cdm(cdm_name)
        ids_by_class_names = new_cdm.get_ids_by_class_names()
        class1_id = ids_by_class_names[class1_name]
        class2_id = ids_by_class_names[class2_name]
        class2_ae_ids = [ae._id for ae in new_cdm[class2_id].associationEnds]
        new_assoc_mapping = new_cdm.get_associations_by_ids()
        new_assoc_ids: set[str] = new_assoc_mapping.keys() - old_assoc_mapping
        if len(new_assoc_ids) != 1:
            warn(f&#34;MockStudent.create_association(): The number of new _ids is {len(new_assoc_ids)} instead of 1.&#34;)
        assoc_id = new_assoc_ids.pop()
        assoc_end_ids: list[str] = new_cdm[assoc_id].ends
        # ae1 here means the association end that refers to class1 and is contained in class2
        ae1 = assoc_end_ids[0] if assoc_end_ids[0] in class2_ae_ids else assoc_end_ids[1]  # eg, Airplane.pilots
        ae2 = assoc_end_ids[0] if assoc_end_ids[0] != ae1 else assoc_end_ids[1]            # eg, Pilot.airplanes

        # Set the multiplicities of the association ends if different from 1 (the default)
        for ae, lb, ub in ((ae1, ae1lb, ae1ub), (ae2, ae2lb, ae2ub)):
            if not lb == ub == 1:  # if both are 1, save an API call
                resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/multiplicity&#34;,
                                    headers=self._auth_header, json={&#34;lowerBound&#34;: lb, &#34;upperBound&#34;: ub})
                resp.raise_for_status()

        # Set the rolenames of the association ends
        for ae, rolename in ((ae1, rolename1), (ae2, rolename2)):
            resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/rolename&#34;,
                                headers=self._auth_header, json={&#34;roleName&#34;: rolename})
            resp.raise_for_status()

        # Set the reference types of the association ends if not Regular (the default)
        for ae, reftype in ((ae1, reftype1), (ae2, reftype2)):
            if reftype != &#34;Regular&#34;:
                resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/referencetype&#34;,
                                    headers=self._auth_header, json={&#34;referenceType&#34;: reftype})
                resp.raise_for_status()

        # eg, Pilot, Airplane.pilots, Pilot_Airplane, Pilot.airplanes, Airplane
        return (class1_id, ae1, assoc_id, ae2, class2_id)

    def create_composition(self, cdm_name: str,
        whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
        whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
        part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create a composition with the given inputs and return a 5-tuple,
        (whole_class_id, whole_ae_id, compos_id, part_ae_id, part_class_id). See create_association() for parameter
        details. Note that the AssociationEnd with the part_rolename refers to the Part class and is contained in the
        Whole class and has the Composition ReferenceType.

        Example:
        ```
        1  Car car &lt;@&gt;- 1 Engine engine
        |   |   |       |    |      |
        |   |   |       |  Part     |
        |   |   |       |           |
        | Whole | part_multiplicity |
        |       |                   |
        |  whole_rolename           |
        |                           |
        whole_multiplicity    part_rolename (composend)
        ```
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments
        return self.create_association(
            cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
            part_rolename, bidirectional, &#34;Regular&#34;, &#34;Composition&#34;)

    def create_aggregation(self, cdm_name: str,
        whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
        whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
        part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
        &#34;&#34;&#34;
        Create an aggregation with the given inputs and return a 5-tuple,
        (whole_class_id, whole_ae_id, aggr_id, part_ae_id, part_class_id). See the methods above for parameter details.
        &#34;&#34;&#34;
        # pylint: disable=too-many-arguments
        return self.create_association(
            cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
            part_rolename, bidirectional, &#34;Regular&#34;, &#34;Aggregation&#34;)

    def request_feedback(self, cdm_name: str) -&gt; FeedbackTO:
        &#34;Request feedback from the Modeling Assistant via WebCORE.&#34;
        resp = requests.get(f&#34;{self.cdm_endpoint(cdm_name)}/feedback&#34;, headers=self._auth_header)
        print(f&#34;{resp.text = }&#34;)
        resp.raise_for_status()
        feedback_json = resp.json()
        return FeedbackTO(**feedback_json)

    def get_cdm(self, cdm_name: str) -&gt; ClassDiagramDTO:
        &#34;Get the student&#39;s class diagram with the given name from WebCORE in JSON format.&#34;
        resp = requests.get(self.cdm_endpoint(cdm_name), headers=self._auth_header)
        resp.raise_for_status()
        self._cdm = ClassDiagramDTO(resp.json(object_hook=to_simplenamespace))
        logger.debug(self._cdm)
        return self._cdm

    def cdm_endpoint(self, cdm_name: str) -&gt; str:
        &#34;Return the class diagram endpoint for the student with the given name.&#34;
        return f&#34;{WEBCORE_ENDPOINT}/{self.name}/classdiagram/{cdm_name}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="user.User" href="#user.User">User</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="user.MockStudent.cdm_endpoint"><code class="name flex">
<span>def <span class="ident">cdm_endpoint</span></span>(<span>self, cdm_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the class diagram endpoint for the student with the given name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdm_endpoint(self, cdm_name: str) -&gt; str:
    &#34;Return the class diagram endpoint for the student with the given name.&#34;
    return f&#34;{WEBCORE_ENDPOINT}/{self.name}/classdiagram/{cdm_name}&#34;</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_aggregation"><code class="name flex">
<span>def <span class="ident">create_aggregation</span></span>(<span>self, cdm_name: str, whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = '', whole_rolename: str = '', part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = '', part_rolename: str = '', bidirectional: bool = True) ‑> tuple[str, str, str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create an aggregation with the given inputs and return a 5-tuple,
(whole_class_id, whole_ae_id, aggr_id, part_ae_id, part_class_id). See the methods above for parameter details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_aggregation(self, cdm_name: str,
    whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
    whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
    part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
    &#34;&#34;&#34;
    Create an aggregation with the given inputs and return a 5-tuple,
    (whole_class_id, whole_ae_id, aggr_id, part_ae_id, part_class_id). See the methods above for parameter details.
    &#34;&#34;&#34;
    # pylint: disable=too-many-arguments
    return self.create_association(
        cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
        part_rolename, bidirectional, &#34;Regular&#34;, &#34;Aggregation&#34;)</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_association"><code class="name flex">
<span>def <span class="ident">create_association</span></span>(<span>self, cdm_name: str, multiplicities1: int | tuple[int, int] = 1, class1_id: str = '', rolename1: str = '', multiplicities2: int | tuple[int, int] = 1, class2_id: str = '', rolename2: str = '', bidirectional: bool = True, reftype1: AeReferenceType = 'Regular', reftype2: AeReferenceType = 'Regular') ‑> tuple[str, str, str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create an association with the given inputs, which are ordered in mostly the same way as Umple:</p>
<p>multiplicities1, class1_id, rolename1, multiplicities2, class2_id, rolename2, bidrectional, reftype1, reftype2</p>
<p>(The last three arguments are at the end because they are optional.)</p>
<p>For example:</p>
<pre><code>1..2   Pilot      pilots  --   *   Airplane      airplanes
</code></pre>
<p>-&gt; (1, 2), pilot_id, "pilots",
MANY, airplane_id, "airplanes", Regular, Regular</p>
<p>The return value is a 5-tuple: (class1_id, ae1_id, assoc_id, ae2_id, class2_id).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_association(self, cdm_name: str,
    multiplicities1: int | tuple[int, int] = 1, class1_id: str = &#34;&#34;, rolename1: str = &#34;&#34;,
    multiplicities2: int | tuple[int, int] = 1, class2_id: str = &#34;&#34;, rolename2: str = &#34;&#34;,
    bidirectional: bool = True, reftype1: AeReferenceType = &#34;Regular&#34;, reftype2: AeReferenceType = &#34;Regular&#34;
) -&gt; tuple[str, str, str, str, str]:
    &#34;&#34;&#34;
    Create an association with the given inputs, which are ordered in mostly the same way as Umple:

    multiplicities1, class1_id, rolename1, multiplicities2, class2_id, rolename2, bidrectional, reftype1, reftype2

    (The last three arguments are at the end because they are optional.)

    For example:

        1..2   Pilot      pilots  --   *   Airplane      airplanes

    -&gt; (1, 2), pilot_id, &#34;pilots&#34;,   MANY, airplane_id, &#34;airplanes&#34;, Regular, Regular

    The return value is a 5-tuple: (class1_id, ae1_id, assoc_id, ae2_id, class2_id).
    &#34;&#34;&#34;
    # pylint: disable=too-many-arguments, too-many-locals, protected-access
    def value_or_index(element: int | tuple[int, int], index=0) -&gt; int:
        return element if isinstance(element, int) else element[index]

    if not class1_id or not class2_id:
        raise ValueError(f&#34;MockStudent.create_association(): {class1_id = } and/or {class2_id = } not valid.&#34;)
    # AssociationEnd lower and upper bounds
    ae1lb, ae1ub = value_or_index(multiplicities1), value_or_index(multiplicities1, 1)  # eg,  1,  2
    ae2lb, ae2ub = value_or_index(multiplicities2), value_or_index(multiplicities2, 1)  # eg, -1, -1
    old_class_names = self._cdm.get_class_names_by_ids()
    class1_name = old_class_names[class1_id]
    class2_name = old_class_names[class2_id]
    old_assoc_mapping = self._cdm.get_associations_by_ids()
    # Rudimentary pluralization when upper bound is 2+ or -1 (*)
    rolename1 = rolename1 or f&#34;{class1_name[0].lower()}{class1_name[1:]}{&#39;s&#39; if ae1ub != 1 else &#39;&#39;}&#34;  # eg, pilots
    rolename2 = rolename2 or f&#34;{class2_name[0].lower()}{class2_name[1:]}{&#39;s&#39; if ae2ub != 1 else &#39;&#39;}&#34;  # eg, airpl.

    # Create the association itself
    resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association&#34;, headers=self._auth_header,
                         json={&#34;fromClassId&#34;: class1_id, &#34;toClassId&#34;: class2_id, &#34;bidirectional&#34;: bidirectional})
    resp.raise_for_status()
    new_cdm = self.get_cdm(cdm_name)
    ids_by_class_names = new_cdm.get_ids_by_class_names()
    class1_id = ids_by_class_names[class1_name]
    class2_id = ids_by_class_names[class2_name]
    class2_ae_ids = [ae._id for ae in new_cdm[class2_id].associationEnds]
    new_assoc_mapping = new_cdm.get_associations_by_ids()
    new_assoc_ids: set[str] = new_assoc_mapping.keys() - old_assoc_mapping
    if len(new_assoc_ids) != 1:
        warn(f&#34;MockStudent.create_association(): The number of new _ids is {len(new_assoc_ids)} instead of 1.&#34;)
    assoc_id = new_assoc_ids.pop()
    assoc_end_ids: list[str] = new_cdm[assoc_id].ends
    # ae1 here means the association end that refers to class1 and is contained in class2
    ae1 = assoc_end_ids[0] if assoc_end_ids[0] in class2_ae_ids else assoc_end_ids[1]  # eg, Airplane.pilots
    ae2 = assoc_end_ids[0] if assoc_end_ids[0] != ae1 else assoc_end_ids[1]            # eg, Pilot.airplanes

    # Set the multiplicities of the association ends if different from 1 (the default)
    for ae, lb, ub in ((ae1, ae1lb, ae1ub), (ae2, ae2lb, ae2ub)):
        if not lb == ub == 1:  # if both are 1, save an API call
            resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/multiplicity&#34;,
                                headers=self._auth_header, json={&#34;lowerBound&#34;: lb, &#34;upperBound&#34;: ub})
            resp.raise_for_status()

    # Set the rolenames of the association ends
    for ae, rolename in ((ae1, rolename1), (ae2, rolename2)):
        resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/rolename&#34;,
                            headers=self._auth_header, json={&#34;roleName&#34;: rolename})
        resp.raise_for_status()

    # Set the reference types of the association ends if not Regular (the default)
    for ae, reftype in ((ae1, reftype1), (ae2, reftype2)):
        if reftype != &#34;Regular&#34;:
            resp = requests.put(f&#34;{self.cdm_endpoint(cdm_name)}/association/end/{ae}/referencetype&#34;,
                                headers=self._auth_header, json={&#34;referenceType&#34;: reftype})
            resp.raise_for_status()

    # eg, Pilot, Airplane.pilots, Pilot_Airplane, Pilot.airplanes, Airplane
    return (class1_id, ae1, assoc_id, ae2, class2_id)</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_attribute"><code class="name flex">
<span>def <span class="ident">create_attribute</span></span>(<span>self, cdm_name: str, cls_id: str, attr_name: str, attr_type: type | str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create an attribute with the given name and return its _id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_attribute(self, cdm_name: str, cls_id: str, attr_name: str, attr_type: type | str) -&gt; str:
    &#34;Create an attribute with the given name and return its _id.&#34;
    old_cdm = self.get_cdm(cdm_name)
    resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}/attribute&#34;, headers=self._auth_header,
                         json={&#34;rankIndex&#34;: 0, &#34;typeId&#34;: old_cdm.type_id_for(attr_type),
                               &#34;attributeName&#34;: attr_name})
    resp.raise_for_status()
    new_cdm = self.get_cdm(cdm_name)
    logger.debug(cdm_diff(old_cdm, new_cdm))
    attr_id = cdm_diff(old_cdm, new_cdm).additions[0]
    logger.debug(f&#34;MockStudent.create_attribute(): Returning {attr_id = }&#34;)
    return attr_id</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_cdm"><code class="name flex">
<span>def <span class="ident">create_cdm</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Create a student class diagram.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cdm(self, name: str) -&gt; bool:
    &#34;Create a student class diagram.&#34;
    resp = requests.put(self.cdm_endpoint(name), headers=self._auth_header)
    return resp.ok</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_class"><code class="name flex">
<span>def <span class="ident">create_class</span></span>(<span>self, cdm_name: str, cls_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Create a class with the given name in the given class diagram belonging to the student and return its _id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_class(self, cdm_name: str, cls_name: str) -&gt; str:
    &#34;Create a class with the given name in the given class diagram belonging to the student and return its _id.&#34;
    old_cdm = self.get_cdm(cdm_name)
    old_class_mapping = old_cdm.get_class_names_by_ids()
    resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/class&#34;, headers=self._auth_header,
                         json={&#34;className&#34;: cls_name, &#34;dataType&#34;: False, &#34;isInterface&#34;: False,
                               &#34;x&#34;: randint(0, 600), &#34;y&#34;: randint(0, 600)})
    resp.raise_for_status()
    new_cdm = self.get_cdm(cdm_name)
    new_cdm_mapping = new_cdm.get_class_names_by_ids()
    new_ids: set[str] = new_cdm_mapping.keys() - old_class_mapping
    if len(new_ids) != 1:
        warn(f&#34;MockStudent.create_class(): The number of new _ids is {len(new_ids)} instead of 1.&#34;)
    cls_id = new_ids.pop()
    logger.debug(f&#34;MockStudent: Created class with _id {cls_id}&#34;)
    return cls_id</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_composition"><code class="name flex">
<span>def <span class="ident">create_composition</span></span>(<span>self, cdm_name: str, whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = '', whole_rolename: str = '', part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = '', part_rolename: str = '', bidirectional: bool = True) ‑> tuple[str, str, str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a composition with the given inputs and return a 5-tuple,
(whole_class_id, whole_ae_id, compos_id, part_ae_id, part_class_id). See create_association() for parameter
details. Note that the AssociationEnd with the part_rolename refers to the Part class and is contained in the
Whole class and has the Composition ReferenceType.</p>
<p>Example:</p>
<pre><code>1  Car car &lt;@&gt;- 1 Engine engine
|   |   |       |    |      |
|   |   |       |  Part     |
|   |   |       |           |
| Whole | part_multiplicity |
|       |                   |
|  whole_rolename           |
|                           |
whole_multiplicity    part_rolename (composend)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_composition(self, cdm_name: str,
    whole_multiplicities: Literal[1] | tuple[Literal[0], Literal[1]] = 1, whole_class_id: str = &#34;&#34;,
    whole_rolename: str = &#34;&#34;, part_multiplicities: int | tuple[int, int] = 1, part_class_id: str = &#34;&#34;,
    part_rolename: str = &#34;&#34;, bidirectional: bool = True) -&gt; tuple[str, str, str, str, str]:
    &#34;&#34;&#34;
    Create a composition with the given inputs and return a 5-tuple,
    (whole_class_id, whole_ae_id, compos_id, part_ae_id, part_class_id). See create_association() for parameter
    details. Note that the AssociationEnd with the part_rolename refers to the Part class and is contained in the
    Whole class and has the Composition ReferenceType.

    Example:
    ```
    1  Car car &lt;@&gt;- 1 Engine engine
    |   |   |       |    |      |
    |   |   |       |  Part     |
    |   |   |       |           |
    | Whole | part_multiplicity |
    |       |                   |
    |  whole_rolename           |
    |                           |
    whole_multiplicity    part_rolename (composend)
    ```
    &#34;&#34;&#34;
    # pylint: disable=too-many-arguments
    return self.create_association(
        cdm_name, whole_multiplicities, whole_class_id, whole_rolename, part_multiplicities, part_class_id,
        part_rolename, bidirectional, &#34;Regular&#34;, &#34;Composition&#34;)</code></pre>
</details>
</dd>
<dt id="user.MockStudent.create_generalization"><code class="name flex">
<span>def <span class="ident">create_generalization</span></span>(<span>self, cdm_name: str, subclass_id: str, superclass_id: str) ‑> tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a generalization between the given subclass and superclass and return their _id's in that order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_generalization(self, cdm_name: str, subclass_id: str, superclass_id: str) -&gt; tuple[str, str]:
    &#34;Create a generalization between the given subclass and superclass and return their _id&#39;s in that order.&#34;
    old_class_names = self._cdm.get_class_names_by_ids()
    subclass_name = old_class_names[subclass_id]
    superclass_name = old_class_names[superclass_id]
    resp = requests.post(f&#34;{self.cdm_endpoint(cdm_name)}/association/supertype&#34;, headers=self._auth_header,
                            json={&#34;subClassId&#34;: subclass_id, &#34;superClassId&#34;: superclass_id})
    resp.raise_for_status()
    # The _ids of the subclass and superclass may change, so we need a 2nd API call to GET the new ones
    new_class_ids = self.get_cdm(cdm_name).get_ids_by_class_names()
    subclass_id = new_class_ids[subclass_name]
    superclass_id = new_class_ids[superclass_name]
    return subclass_id, superclass_id</code></pre>
</details>
</dd>
<dt id="user.MockStudent.delete_attribute"><code class="name flex">
<span>def <span class="ident">delete_attribute</span></span>(<span>self, cdm_name: str, attr_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the attribute from the given class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_attribute(self, cdm_name: str, attr_id: str):
    &#34;Delete the attribute from the given class.&#34;
    resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/attribute/{attr_id}&#34;,
                           headers=self._auth_header)
    resp.raise_for_status()</code></pre>
</details>
</dd>
<dt id="user.MockStudent.delete_class"><code class="name flex">
<span>def <span class="ident">delete_class</span></span>(<span>self, cdm_name: str, cls_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the class with the given _id from the given class diagram belonging to the student.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_class(self, cdm_name: str, cls_id: str):
    &#34;Delete the class with the given _id from the given class diagram belonging to the student.&#34;
    resp = requests.delete(f&#34;{self.cdm_endpoint(cdm_name)}/class/{cls_id}&#34;, headers=self._auth_header)
    resp.raise_for_status()</code></pre>
</details>
</dd>
<dt id="user.MockStudent.get_cdm"><code class="name flex">
<span>def <span class="ident">get_cdm</span></span>(<span>self, cdm_name: str) ‑> <a title="utils.ClassDiagramDTO" href="utils.html#utils.ClassDiagramDTO">ClassDiagramDTO</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the student's class diagram with the given name from WebCORE in JSON format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cdm(self, cdm_name: str) -&gt; ClassDiagramDTO:
    &#34;Get the student&#39;s class diagram with the given name from WebCORE in JSON format.&#34;
    resp = requests.get(self.cdm_endpoint(cdm_name), headers=self._auth_header)
    resp.raise_for_status()
    self._cdm = ClassDiagramDTO(resp.json(object_hook=to_simplenamespace))
    logger.debug(self._cdm)
    return self._cdm</code></pre>
</details>
</dd>
<dt id="user.MockStudent.request_feedback"><code class="name flex">
<span>def <span class="ident">request_feedback</span></span>(<span>self, cdm_name: str) ‑> <a title="feedback.FeedbackTO" href="feedback.html#feedback.FeedbackTO">FeedbackTO</a></span>
</code></dt>
<dd>
<div class="desc"><p>Request feedback from the Modeling Assistant via WebCORE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_feedback(self, cdm_name: str) -&gt; FeedbackTO:
    &#34;Request feedback from the Modeling Assistant via WebCORE.&#34;
    resp = requests.get(f&#34;{self.cdm_endpoint(cdm_name)}/feedback&#34;, headers=self._auth_header)
    print(f&#34;{resp.text = }&#34;)
    resp.raise_for_status()
    feedback_json = resp.json()
    return FeedbackTO(**feedback_json)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="user.User"><code class="flex name class">
<span>class <span class="ident">User</span></span>
<span>(</span><span>name: str, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent a user.</p>
<p>Register a new user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class User:
    &#34;Class to represent a user.&#34;
    def __init__(self, name: str, password):
        &#34;Register a new user.&#34;
        if name in users:
            raise ValueError(f&#34;Username {name} already exists.&#34;)
        self.name = name
        self.password = password
        self.token = self.get_token()
        self._logged_in = False
        users[name] = self

    def get_token(self):
        &#34;Get the user&#39;s token.&#34;
        response = requests.put(USER_REGISTER_ENDPOINT, json=self._auth_creds)
        if not response.ok:
            raise ValueError(f&#34;Could not get token for user {self.name}.\nError: {response.text}&#34;)
        return response.text.strip().removeprefix(&#34;User registered. Your authorization token is &#39;&#34;).removesuffix(
            &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)

    def login(self) -&gt; bool:
        &#34;Login the user and update their token if needed.&#34;
        response = requests.post(USER_LOGIN_ENDPOINT, headers=self._auth_header, json=self._auth_creds)
        if not response.ok:
            return False
        self.token = response.text.strip().removeprefix(&#34;Logged in. Your authorization token is &#39;&#34;).removesuffix(
            &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)
        self._logged_in = True
        return True

    def logout(self) -&gt; bool:
        &#34;Logout the user.&#34;
        response = requests.post(USER_LOGOUT_ENDPOINT, headers=self._auth_header)
        if not response.ok:
            return False
        del self.token  # token invalidated in WebCORE, so get rid of here on the client side as well
        self._logged_in = False
        return True

    @property
    def logged_in(self):
        &#34;Return True if the user is logged in.&#34;
        return self._logged_in

    @property
    def _auth_creds(self):
        &#34;Return the user&#39;s authorization credentials.&#34;
        return {&#34;username&#34;: self.name, &#34;password&#34;: self.password}

    @property
    def _auth_header(self):
        &#34;Get the user&#39;s authorization header.&#34;
        return {&#34;Authorization&#34;: f&#34;Bearer {self.token}&#34;} if hasattr(self, &#34;token&#34;) else {}

    @classmethod
    def create_random(cls):
        &#34;Create a user with a random name and password, useful for testing.&#34;
        # fully ensure unique name for new user by using current timestamp
        name = f&#34;{&#39;&#39;.join(random.sample(ascii_lowercase, _USERNAME_PREFIX_LENGTH))}{int(time())}&#34;
        password = secrets.token_urlsafe(16)
        return cls(name, password)  # use cls here to allow the creation of User subclasses

    def __repr__(self) -&gt; str:
        # TODO token returned for debugging only, remove before release
        return f&#39;{self.__class__.__name__}(name=&#34;{self.name}&#34;, token=&#34;{self.token}&#34;)&#39;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="user.MockStudent" href="#user.MockStudent">MockStudent</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="user.User.create_random"><code class="name flex">
<span>def <span class="ident">create_random</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a user with a random name and password, useful for testing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def create_random(cls):
    &#34;Create a user with a random name and password, useful for testing.&#34;
    # fully ensure unique name for new user by using current timestamp
    name = f&#34;{&#39;&#39;.join(random.sample(ascii_lowercase, _USERNAME_PREFIX_LENGTH))}{int(time())}&#34;
    password = secrets.token_urlsafe(16)
    return cls(name, password)  # use cls here to allow the creation of User subclasses</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="user.User.logged_in"><code class="name">var <span class="ident">logged_in</span></code></dt>
<dd>
<div class="desc"><p>Return True if the user is logged in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def logged_in(self):
    &#34;Return True if the user is logged in.&#34;
    return self._logged_in</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="user.User.get_token"><code class="name flex">
<span>def <span class="ident">get_token</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the user's token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token(self):
    &#34;Get the user&#39;s token.&#34;
    response = requests.put(USER_REGISTER_ENDPOINT, json=self._auth_creds)
    if not response.ok:
        raise ValueError(f&#34;Could not get token for user {self.name}.\nError: {response.text}&#34;)
    return response.text.strip().removeprefix(&#34;User registered. Your authorization token is &#39;&#34;).removesuffix(
        &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)</code></pre>
</details>
</dd>
<dt id="user.User.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Login the user and update their token if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login(self) -&gt; bool:
    &#34;Login the user and update their token if needed.&#34;
    response = requests.post(USER_LOGIN_ENDPOINT, headers=self._auth_header, json=self._auth_creds)
    if not response.ok:
        return False
    self.token = response.text.strip().removeprefix(&#34;Logged in. Your authorization token is &#39;&#34;).removesuffix(
        &#34;&#39;. Please embed this token in the header as &#39;Authorization : Bearer &lt;token&gt;&#39; for the subsequent requests.&#34;)
    self._logged_in = True
    return True</code></pre>
</details>
</dd>
<dt id="user.User.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Logout the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logout(self) -&gt; bool:
    &#34;Logout the user.&#34;
    response = requests.post(USER_LOGOUT_ENDPOINT, headers=self._auth_header)
    if not response.ok:
        return False
    del self.token  # token invalidated in WebCORE, so get rid of here on the client side as well
    self._logged_in = False
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="user.MockStudent" href="#user.MockStudent">MockStudent</a></code></h4>
<ul class="">
<li><code><a title="user.MockStudent.cdm_endpoint" href="#user.MockStudent.cdm_endpoint">cdm_endpoint</a></code></li>
<li><code><a title="user.MockStudent.create_aggregation" href="#user.MockStudent.create_aggregation">create_aggregation</a></code></li>
<li><code><a title="user.MockStudent.create_association" href="#user.MockStudent.create_association">create_association</a></code></li>
<li><code><a title="user.MockStudent.create_attribute" href="#user.MockStudent.create_attribute">create_attribute</a></code></li>
<li><code><a title="user.MockStudent.create_cdm" href="#user.MockStudent.create_cdm">create_cdm</a></code></li>
<li><code><a title="user.MockStudent.create_class" href="#user.MockStudent.create_class">create_class</a></code></li>
<li><code><a title="user.MockStudent.create_composition" href="#user.MockStudent.create_composition">create_composition</a></code></li>
<li><code><a title="user.MockStudent.create_generalization" href="#user.MockStudent.create_generalization">create_generalization</a></code></li>
<li><code><a title="user.MockStudent.delete_attribute" href="#user.MockStudent.delete_attribute">delete_attribute</a></code></li>
<li><code><a title="user.MockStudent.delete_class" href="#user.MockStudent.delete_class">delete_class</a></code></li>
<li><code><a title="user.MockStudent.get_cdm" href="#user.MockStudent.get_cdm">get_cdm</a></code></li>
<li><code><a title="user.MockStudent.request_feedback" href="#user.MockStudent.request_feedback">request_feedback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="user.User" href="#user.User">User</a></code></h4>
<ul class="">
<li><code><a title="user.User.create_random" href="#user.User.create_random">create_random</a></code></li>
<li><code><a title="user.User.get_token" href="#user.User.get_token">get_token</a></code></li>
<li><code><a title="user.User.logged_in" href="#user.User.logged_in">logged_in</a></code></li>
<li><code><a title="user.User.login" href="#user.User.login">login</a></code></li>
<li><code><a title="user.User.logout" href="#user.User.logout">logout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>